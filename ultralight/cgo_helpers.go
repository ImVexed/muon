// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sun, 02 Oct 2022 19:40:55 PDT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package ultralight

/*
#cgo CFLAGS: -I../include
#cgo LDFLAGS: -Wl,--allow-multiple-definition -L${SRCDIR}/libs/linux/x64 -Wl,-rpath,/home/co/code/Muon/ultralight/libs/linux/x64 -lUltralightCore -lAppCore -lUltralight -lWebCore
#include "AppCore/CAPI.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

func (x ULUpdateCallback) PassRef() (ref *C.ULUpdateCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLUpdateCallback7E1C6355Func == nil {
		uLUpdateCallback7E1C6355Func = x
	}
	return (*C.ULUpdateCallback)(C.ULUpdateCallback_7e1c6355), nil
}

func (x ULUpdateCallback) PassValue() (ref C.ULUpdateCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLUpdateCallback7E1C6355Func == nil {
		uLUpdateCallback7E1C6355Func = x
	}
	return (C.ULUpdateCallback)(C.ULUpdateCallback_7e1c6355), nil
}

func NewULUpdateCallbackRef(ref unsafe.Pointer) *ULUpdateCallback {
	return (*ULUpdateCallback)(ref)
}

//export uLUpdateCallback7E1C6355
func uLUpdateCallback7E1C6355(cuserData unsafe.Pointer) {
	if uLUpdateCallback7E1C6355Func != nil {
		userData7e1c6355 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		uLUpdateCallback7E1C6355Func(userData7e1c6355)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLUpdateCallback7E1C6355Func ULUpdateCallback

func (x ULCloseCallback) PassRef() (ref *C.ULCloseCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLCloseCallback195B2F9Func == nil {
		uLCloseCallback195B2F9Func = x
	}
	return (*C.ULCloseCallback)(C.ULCloseCallback_195b2f9), nil
}

func (x ULCloseCallback) PassValue() (ref C.ULCloseCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLCloseCallback195B2F9Func == nil {
		uLCloseCallback195B2F9Func = x
	}
	return (C.ULCloseCallback)(C.ULCloseCallback_195b2f9), nil
}

func NewULCloseCallbackRef(ref unsafe.Pointer) *ULCloseCallback {
	return (*ULCloseCallback)(ref)
}

//export uLCloseCallback195B2F9
func uLCloseCallback195B2F9(cuserData unsafe.Pointer) {
	if uLCloseCallback195B2F9Func != nil {
		userData195b2f9 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		uLCloseCallback195B2F9Func(userData195b2f9)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLCloseCallback195B2F9Func ULCloseCallback

func (x ULResizeCallback) PassRef() (ref *C.ULResizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLResizeCallback6E7309D9Func == nil {
		uLResizeCallback6E7309D9Func = x
	}
	return (*C.ULResizeCallback)(C.ULResizeCallback_6e7309d9), nil
}

func (x ULResizeCallback) PassValue() (ref C.ULResizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLResizeCallback6E7309D9Func == nil {
		uLResizeCallback6E7309D9Func = x
	}
	return (C.ULResizeCallback)(C.ULResizeCallback_6e7309d9), nil
}

func NewULResizeCallbackRef(ref unsafe.Pointer) *ULResizeCallback {
	return (*ULResizeCallback)(ref)
}

//export uLResizeCallback6E7309D9
func uLResizeCallback6E7309D9(cuserData unsafe.Pointer, cwidth C.uint, cheight C.uint) {
	if uLResizeCallback6E7309D9Func != nil {
		userData6e7309d9 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		width6e7309d9 := (uint32)(cwidth)
		height6e7309d9 := (uint32)(cheight)
		uLResizeCallback6E7309D9Func(userData6e7309d9, width6e7309d9, height6e7309d9)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLResizeCallback6E7309D9Func ULResizeCallback

// allocULRectMemory allocates memory for type C.ULRect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULRectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULRectValue = unsafe.Sizeof([1]C.ULRect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULRect) Ref() *C.ULRect {
	if x == nil {
		return nil
	}
	return x.ref4622ce0c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULRect) Free() {
	if x != nil && x.allocs4622ce0c != nil {
		x.allocs4622ce0c.(*cgoAllocMap).Free()
		x.ref4622ce0c = nil
	}
}

// NewULRectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULRectRef(ref unsafe.Pointer) *ULRect {
	if ref == nil {
		return nil
	}
	obj := new(ULRect)
	obj.ref4622ce0c = (*C.ULRect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULRect) PassRef() (*C.ULRect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4622ce0c != nil {
		return x.ref4622ce0c, nil
	}
	mem4622ce0c := allocULRectMemory(1)
	ref4622ce0c := (*C.ULRect)(mem4622ce0c)
	allocs4622ce0c := new(cgoAllocMap)
	allocs4622ce0c.Add(mem4622ce0c)

	var cleft_allocs *cgoAllocMap
	ref4622ce0c.left, cleft_allocs = (C.float)(x.Left), cgoAllocsUnknown
	allocs4622ce0c.Borrow(cleft_allocs)

	var ctop_allocs *cgoAllocMap
	ref4622ce0c.top, ctop_allocs = (C.float)(x.Top), cgoAllocsUnknown
	allocs4622ce0c.Borrow(ctop_allocs)

	var cright_allocs *cgoAllocMap
	ref4622ce0c.right, cright_allocs = (C.float)(x.Right), cgoAllocsUnknown
	allocs4622ce0c.Borrow(cright_allocs)

	var cbottom_allocs *cgoAllocMap
	ref4622ce0c.bottom, cbottom_allocs = (C.float)(x.Bottom), cgoAllocsUnknown
	allocs4622ce0c.Borrow(cbottom_allocs)

	x.ref4622ce0c = ref4622ce0c
	x.allocs4622ce0c = allocs4622ce0c
	return ref4622ce0c, allocs4622ce0c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULRect) PassValue() (C.ULRect, *cgoAllocMap) {
	if x.ref4622ce0c != nil {
		return *x.ref4622ce0c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULRect) Deref() {
	if x.ref4622ce0c == nil {
		return
	}
	x.Left = (float32)(x.ref4622ce0c.left)
	x.Top = (float32)(x.ref4622ce0c.top)
	x.Right = (float32)(x.ref4622ce0c.right)
	x.Bottom = (float32)(x.ref4622ce0c.bottom)
}

// allocULIntRectMemory allocates memory for type C.ULIntRect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULIntRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULIntRectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULIntRectValue = unsafe.Sizeof([1]C.ULIntRect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULIntRect) Ref() *C.ULIntRect {
	if x == nil {
		return nil
	}
	return x.ref79619c19
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULIntRect) Free() {
	if x != nil && x.allocs79619c19 != nil {
		x.allocs79619c19.(*cgoAllocMap).Free()
		x.ref79619c19 = nil
	}
}

// NewULIntRectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULIntRectRef(ref unsafe.Pointer) *ULIntRect {
	if ref == nil {
		return nil
	}
	obj := new(ULIntRect)
	obj.ref79619c19 = (*C.ULIntRect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULIntRect) PassRef() (*C.ULIntRect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref79619c19 != nil {
		return x.ref79619c19, nil
	}
	mem79619c19 := allocULIntRectMemory(1)
	ref79619c19 := (*C.ULIntRect)(mem79619c19)
	allocs79619c19 := new(cgoAllocMap)
	allocs79619c19.Add(mem79619c19)

	var cleft_allocs *cgoAllocMap
	ref79619c19.left, cleft_allocs = (C.int)(x.Left), cgoAllocsUnknown
	allocs79619c19.Borrow(cleft_allocs)

	var ctop_allocs *cgoAllocMap
	ref79619c19.top, ctop_allocs = (C.int)(x.Top), cgoAllocsUnknown
	allocs79619c19.Borrow(ctop_allocs)

	var cright_allocs *cgoAllocMap
	ref79619c19.right, cright_allocs = (C.int)(x.Right), cgoAllocsUnknown
	allocs79619c19.Borrow(cright_allocs)

	var cbottom_allocs *cgoAllocMap
	ref79619c19.bottom, cbottom_allocs = (C.int)(x.Bottom), cgoAllocsUnknown
	allocs79619c19.Borrow(cbottom_allocs)

	x.ref79619c19 = ref79619c19
	x.allocs79619c19 = allocs79619c19
	return ref79619c19, allocs79619c19

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULIntRect) PassValue() (C.ULIntRect, *cgoAllocMap) {
	if x.ref79619c19 != nil {
		return *x.ref79619c19, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULIntRect) Deref() {
	if x.ref79619c19 == nil {
		return
	}
	x.Left = (int32)(x.ref79619c19.left)
	x.Top = (int32)(x.ref79619c19.top)
	x.Right = (int32)(x.ref79619c19.right)
	x.Bottom = (int32)(x.ref79619c19.bottom)
}

// allocULRenderTargetMemory allocates memory for type C.ULRenderTarget in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULRenderTargetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULRenderTargetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULRenderTargetValue = unsafe.Sizeof([1]C.ULRenderTarget{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULRenderTarget) Ref() *C.ULRenderTarget {
	if x == nil {
		return nil
	}
	return x.ref79bb0a51
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULRenderTarget) Free() {
	if x != nil && x.allocs79bb0a51 != nil {
		x.allocs79bb0a51.(*cgoAllocMap).Free()
		x.ref79bb0a51 = nil
	}
}

// NewULRenderTargetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULRenderTargetRef(ref unsafe.Pointer) *ULRenderTarget {
	if ref == nil {
		return nil
	}
	obj := new(ULRenderTarget)
	obj.ref79bb0a51 = (*C.ULRenderTarget)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULRenderTarget) PassRef() (*C.ULRenderTarget, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref79bb0a51 != nil {
		return x.ref79bb0a51, nil
	}
	mem79bb0a51 := allocULRenderTargetMemory(1)
	ref79bb0a51 := (*C.ULRenderTarget)(mem79bb0a51)
	allocs79bb0a51 := new(cgoAllocMap)
	allocs79bb0a51.Add(mem79bb0a51)

	var cis_empty_allocs *cgoAllocMap
	ref79bb0a51.is_empty, cis_empty_allocs = (C._Bool)(x.IsEmpty), cgoAllocsUnknown
	allocs79bb0a51.Borrow(cis_empty_allocs)

	var cwidth_allocs *cgoAllocMap
	ref79bb0a51.width, cwidth_allocs = (C.uint)(x.Width), cgoAllocsUnknown
	allocs79bb0a51.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref79bb0a51.height, cheight_allocs = (C.uint)(x.Height), cgoAllocsUnknown
	allocs79bb0a51.Borrow(cheight_allocs)

	var ctexture_id_allocs *cgoAllocMap
	ref79bb0a51.texture_id, ctexture_id_allocs = (C.uint)(x.TextureId), cgoAllocsUnknown
	allocs79bb0a51.Borrow(ctexture_id_allocs)

	var ctexture_width_allocs *cgoAllocMap
	ref79bb0a51.texture_width, ctexture_width_allocs = (C.uint)(x.TextureWidth), cgoAllocsUnknown
	allocs79bb0a51.Borrow(ctexture_width_allocs)

	var ctexture_height_allocs *cgoAllocMap
	ref79bb0a51.texture_height, ctexture_height_allocs = (C.uint)(x.TextureHeight), cgoAllocsUnknown
	allocs79bb0a51.Borrow(ctexture_height_allocs)

	var ctexture_format_allocs *cgoAllocMap
	ref79bb0a51.texture_format, ctexture_format_allocs = (C.ULBitmapFormat)(x.TextureFormat), cgoAllocsUnknown
	allocs79bb0a51.Borrow(ctexture_format_allocs)

	var cuv_coords_allocs *cgoAllocMap
	ref79bb0a51.uv_coords, cuv_coords_allocs = x.UvCoords.PassValue()
	allocs79bb0a51.Borrow(cuv_coords_allocs)

	var crender_buffer_id_allocs *cgoAllocMap
	ref79bb0a51.render_buffer_id, crender_buffer_id_allocs = (C.uint)(x.RenderBufferId), cgoAllocsUnknown
	allocs79bb0a51.Borrow(crender_buffer_id_allocs)

	x.ref79bb0a51 = ref79bb0a51
	x.allocs79bb0a51 = allocs79bb0a51
	return ref79bb0a51, allocs79bb0a51

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULRenderTarget) PassValue() (C.ULRenderTarget, *cgoAllocMap) {
	if x.ref79bb0a51 != nil {
		return *x.ref79bb0a51, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULRenderTarget) Deref() {
	if x.ref79bb0a51 == nil {
		return
	}
	x.IsEmpty = (bool)(x.ref79bb0a51.is_empty)
	x.Width = (uint32)(x.ref79bb0a51.width)
	x.Height = (uint32)(x.ref79bb0a51.height)
	x.TextureId = (uint32)(x.ref79bb0a51.texture_id)
	x.TextureWidth = (uint32)(x.ref79bb0a51.texture_width)
	x.TextureHeight = (uint32)(x.ref79bb0a51.texture_height)
	x.TextureFormat = (ULBitmapFormat)(x.ref79bb0a51.texture_format)
	x.UvCoords = *NewULRectRef(unsafe.Pointer(&x.ref79bb0a51.uv_coords))
	x.RenderBufferId = (uint32)(x.ref79bb0a51.render_buffer_id)
}

func (x ULChangeTitleCallback) PassRef() (ref *C.ULChangeTitleCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeTitleCallbackBD58034CFunc == nil {
		uLChangeTitleCallbackBD58034CFunc = x
	}
	return (*C.ULChangeTitleCallback)(C.ULChangeTitleCallback_bd58034c), nil
}

func (x ULChangeTitleCallback) PassValue() (ref C.ULChangeTitleCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeTitleCallbackBD58034CFunc == nil {
		uLChangeTitleCallbackBD58034CFunc = x
	}
	return (C.ULChangeTitleCallback)(C.ULChangeTitleCallback_bd58034c), nil
}

func NewULChangeTitleCallbackRef(ref unsafe.Pointer) *ULChangeTitleCallback {
	return (*ULChangeTitleCallback)(ref)
}

//export uLChangeTitleCallbackBD58034C
func uLChangeTitleCallbackBD58034C(cuserData unsafe.Pointer, ccaller C.ULView, ctitle C.ULString) {
	if uLChangeTitleCallbackBD58034CFunc != nil {
		userDatabd58034c := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		callerbd58034c := *(*ULView)(unsafe.Pointer(&ccaller))
		titlebd58034c := *(*ULString)(unsafe.Pointer(&ctitle))
		uLChangeTitleCallbackBD58034CFunc(userDatabd58034c, callerbd58034c, titlebd58034c)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLChangeTitleCallbackBD58034CFunc ULChangeTitleCallback

func (x ULChangeURLCallback) PassRef() (ref *C.ULChangeURLCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeURLCallback4EC32B80Func == nil {
		uLChangeURLCallback4EC32B80Func = x
	}
	return (*C.ULChangeURLCallback)(C.ULChangeURLCallback_4ec32b80), nil
}

func (x ULChangeURLCallback) PassValue() (ref C.ULChangeURLCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeURLCallback4EC32B80Func == nil {
		uLChangeURLCallback4EC32B80Func = x
	}
	return (C.ULChangeURLCallback)(C.ULChangeURLCallback_4ec32b80), nil
}

func NewULChangeURLCallbackRef(ref unsafe.Pointer) *ULChangeURLCallback {
	return (*ULChangeURLCallback)(ref)
}

//export uLChangeURLCallback4EC32B80
func uLChangeURLCallback4EC32B80(cuserData unsafe.Pointer, ccaller C.ULView, curl C.ULString) {
	if uLChangeURLCallback4EC32B80Func != nil {
		userData4ec32b80 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		caller4ec32b80 := *(*ULView)(unsafe.Pointer(&ccaller))
		url4ec32b80 := *(*ULString)(unsafe.Pointer(&curl))
		uLChangeURLCallback4EC32B80Func(userData4ec32b80, caller4ec32b80, url4ec32b80)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLChangeURLCallback4EC32B80Func ULChangeURLCallback

func (x ULChangeTooltipCallback) PassRef() (ref *C.ULChangeTooltipCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeTooltipCallback12CA407Func == nil {
		uLChangeTooltipCallback12CA407Func = x
	}
	return (*C.ULChangeTooltipCallback)(C.ULChangeTooltipCallback_12ca407), nil
}

func (x ULChangeTooltipCallback) PassValue() (ref C.ULChangeTooltipCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeTooltipCallback12CA407Func == nil {
		uLChangeTooltipCallback12CA407Func = x
	}
	return (C.ULChangeTooltipCallback)(C.ULChangeTooltipCallback_12ca407), nil
}

func NewULChangeTooltipCallbackRef(ref unsafe.Pointer) *ULChangeTooltipCallback {
	return (*ULChangeTooltipCallback)(ref)
}

//export uLChangeTooltipCallback12CA407
func uLChangeTooltipCallback12CA407(cuserData unsafe.Pointer, ccaller C.ULView, ctooltip C.ULString) {
	if uLChangeTooltipCallback12CA407Func != nil {
		userData12ca407 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		caller12ca407 := *(*ULView)(unsafe.Pointer(&ccaller))
		tooltip12ca407 := *(*ULString)(unsafe.Pointer(&ctooltip))
		uLChangeTooltipCallback12CA407Func(userData12ca407, caller12ca407, tooltip12ca407)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLChangeTooltipCallback12CA407Func ULChangeTooltipCallback

func (x ULChangeCursorCallback) PassRef() (ref *C.ULChangeCursorCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeCursorCallback1A7011DFFunc == nil {
		uLChangeCursorCallback1A7011DFFunc = x
	}
	return (*C.ULChangeCursorCallback)(C.ULChangeCursorCallback_1a7011df), nil
}

func (x ULChangeCursorCallback) PassValue() (ref C.ULChangeCursorCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeCursorCallback1A7011DFFunc == nil {
		uLChangeCursorCallback1A7011DFFunc = x
	}
	return (C.ULChangeCursorCallback)(C.ULChangeCursorCallback_1a7011df), nil
}

func NewULChangeCursorCallbackRef(ref unsafe.Pointer) *ULChangeCursorCallback {
	return (*ULChangeCursorCallback)(ref)
}

//export uLChangeCursorCallback1A7011DF
func uLChangeCursorCallback1A7011DF(cuserData unsafe.Pointer, ccaller C.ULView, ccursor C.ULCursor) {
	if uLChangeCursorCallback1A7011DFFunc != nil {
		userData1a7011df := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		caller1a7011df := *(*ULView)(unsafe.Pointer(&ccaller))
		cursor1a7011df := (ULCursor)(ccursor)
		uLChangeCursorCallback1A7011DFFunc(userData1a7011df, caller1a7011df, cursor1a7011df)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLChangeCursorCallback1A7011DFFunc ULChangeCursorCallback

func (x ULAddConsoleMessageCallback) PassRef() (ref *C.ULAddConsoleMessageCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLAddConsoleMessageCallback44B8DD01Func == nil {
		uLAddConsoleMessageCallback44B8DD01Func = x
	}
	return (*C.ULAddConsoleMessageCallback)(C.ULAddConsoleMessageCallback_44b8dd01), nil
}

func (x ULAddConsoleMessageCallback) PassValue() (ref C.ULAddConsoleMessageCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLAddConsoleMessageCallback44B8DD01Func == nil {
		uLAddConsoleMessageCallback44B8DD01Func = x
	}
	return (C.ULAddConsoleMessageCallback)(C.ULAddConsoleMessageCallback_44b8dd01), nil
}

func NewULAddConsoleMessageCallbackRef(ref unsafe.Pointer) *ULAddConsoleMessageCallback {
	return (*ULAddConsoleMessageCallback)(ref)
}

//export uLAddConsoleMessageCallback44B8DD01
func uLAddConsoleMessageCallback44B8DD01(cuserData unsafe.Pointer, ccaller C.ULView, csource C.ULMessageSource, clevel C.ULMessageLevel, cmessage C.ULString, clineNumber C.uint, ccolumnNumber C.uint, csourceId C.ULString) {
	if uLAddConsoleMessageCallback44B8DD01Func != nil {
		userData44b8dd01 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		caller44b8dd01 := *(*ULView)(unsafe.Pointer(&ccaller))
		source44b8dd01 := (ULMessageSource)(csource)
		level44b8dd01 := (ULMessageLevel)(clevel)
		message44b8dd01 := *(*ULString)(unsafe.Pointer(&cmessage))
		lineNumber44b8dd01 := (uint32)(clineNumber)
		columnNumber44b8dd01 := (uint32)(ccolumnNumber)
		sourceId44b8dd01 := *(*ULString)(unsafe.Pointer(&csourceId))
		uLAddConsoleMessageCallback44B8DD01Func(userData44b8dd01, caller44b8dd01, source44b8dd01, level44b8dd01, message44b8dd01, lineNumber44b8dd01, columnNumber44b8dd01, sourceId44b8dd01)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLAddConsoleMessageCallback44B8DD01Func ULAddConsoleMessageCallback

func (x ULCreateChildViewCallback) PassRef() (ref *C.ULCreateChildViewCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLCreateChildViewCallbackEF6D2CDDFunc == nil {
		uLCreateChildViewCallbackEF6D2CDDFunc = x
	}
	return (*C.ULCreateChildViewCallback)(C.ULCreateChildViewCallback_ef6d2cdd), nil
}

func (x ULCreateChildViewCallback) PassValue() (ref C.ULCreateChildViewCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLCreateChildViewCallbackEF6D2CDDFunc == nil {
		uLCreateChildViewCallbackEF6D2CDDFunc = x
	}
	return (C.ULCreateChildViewCallback)(C.ULCreateChildViewCallback_ef6d2cdd), nil
}

func NewULCreateChildViewCallbackRef(ref unsafe.Pointer) *ULCreateChildViewCallback {
	return (*ULCreateChildViewCallback)(ref)
}

//export uLCreateChildViewCallbackEF6D2CDD
func uLCreateChildViewCallbackEF6D2CDD(cuserData unsafe.Pointer, ccaller C.ULView, copenerUrl C.ULString, ctargetUrl C.ULString, cisPopup C._Bool, cpopupRect C.ULIntRect) C.ULView {
	if uLCreateChildViewCallbackEF6D2CDDFunc != nil {
		userDataef6d2cdd := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		calleref6d2cdd := *(*ULView)(unsafe.Pointer(&ccaller))
		openerUrlef6d2cdd := *(*ULString)(unsafe.Pointer(&copenerUrl))
		targetUrlef6d2cdd := *(*ULString)(unsafe.Pointer(&ctargetUrl))
		isPopupef6d2cdd := (bool)(cisPopup)
		popupRectef6d2cdd := *NewULIntRectRef(unsafe.Pointer(&cpopupRect))
		retef6d2cdd := uLCreateChildViewCallbackEF6D2CDDFunc(userDataef6d2cdd, calleref6d2cdd, openerUrlef6d2cdd, targetUrlef6d2cdd, isPopupef6d2cdd, popupRectef6d2cdd)
		ret, _ := *(*C.ULView)(unsafe.Pointer(&retef6d2cdd)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLCreateChildViewCallbackEF6D2CDDFunc ULCreateChildViewCallback

func (x ULBeginLoadingCallback) PassRef() (ref *C.ULBeginLoadingCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLBeginLoadingCallback70D8C0ADFunc == nil {
		uLBeginLoadingCallback70D8C0ADFunc = x
	}
	return (*C.ULBeginLoadingCallback)(C.ULBeginLoadingCallback_70d8c0ad), nil
}

func (x ULBeginLoadingCallback) PassValue() (ref C.ULBeginLoadingCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLBeginLoadingCallback70D8C0ADFunc == nil {
		uLBeginLoadingCallback70D8C0ADFunc = x
	}
	return (C.ULBeginLoadingCallback)(C.ULBeginLoadingCallback_70d8c0ad), nil
}

func NewULBeginLoadingCallbackRef(ref unsafe.Pointer) *ULBeginLoadingCallback {
	return (*ULBeginLoadingCallback)(ref)
}

//export uLBeginLoadingCallback70D8C0AD
func uLBeginLoadingCallback70D8C0AD(cuserData unsafe.Pointer, ccaller C.ULView, cframeId C.ulonglong, cisMainFrame C._Bool, curl C.ULString) {
	if uLBeginLoadingCallback70D8C0ADFunc != nil {
		userData70d8c0ad := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		caller70d8c0ad := *(*ULView)(unsafe.Pointer(&ccaller))
		frameId70d8c0ad := (uint64)(cframeId)
		isMainFrame70d8c0ad := (bool)(cisMainFrame)
		url70d8c0ad := *(*ULString)(unsafe.Pointer(&curl))
		uLBeginLoadingCallback70D8C0ADFunc(userData70d8c0ad, caller70d8c0ad, frameId70d8c0ad, isMainFrame70d8c0ad, url70d8c0ad)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLBeginLoadingCallback70D8C0ADFunc ULBeginLoadingCallback

func (x ULFinishLoadingCallback) PassRef() (ref *C.ULFinishLoadingCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFinishLoadingCallback1ED4ECAEFunc == nil {
		uLFinishLoadingCallback1ED4ECAEFunc = x
	}
	return (*C.ULFinishLoadingCallback)(C.ULFinishLoadingCallback_1ed4ecae), nil
}

func (x ULFinishLoadingCallback) PassValue() (ref C.ULFinishLoadingCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFinishLoadingCallback1ED4ECAEFunc == nil {
		uLFinishLoadingCallback1ED4ECAEFunc = x
	}
	return (C.ULFinishLoadingCallback)(C.ULFinishLoadingCallback_1ed4ecae), nil
}

func NewULFinishLoadingCallbackRef(ref unsafe.Pointer) *ULFinishLoadingCallback {
	return (*ULFinishLoadingCallback)(ref)
}

//export uLFinishLoadingCallback1ED4ECAE
func uLFinishLoadingCallback1ED4ECAE(cuserData unsafe.Pointer, ccaller C.ULView, cframeId C.ulonglong, cisMainFrame C._Bool, curl C.ULString) {
	if uLFinishLoadingCallback1ED4ECAEFunc != nil {
		userData1ed4ecae := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		caller1ed4ecae := *(*ULView)(unsafe.Pointer(&ccaller))
		frameId1ed4ecae := (uint64)(cframeId)
		isMainFrame1ed4ecae := (bool)(cisMainFrame)
		url1ed4ecae := *(*ULString)(unsafe.Pointer(&curl))
		uLFinishLoadingCallback1ED4ECAEFunc(userData1ed4ecae, caller1ed4ecae, frameId1ed4ecae, isMainFrame1ed4ecae, url1ed4ecae)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLFinishLoadingCallback1ED4ECAEFunc ULFinishLoadingCallback

func (x ULFailLoadingCallback) PassRef() (ref *C.ULFailLoadingCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFailLoadingCallback55FF90B8Func == nil {
		uLFailLoadingCallback55FF90B8Func = x
	}
	return (*C.ULFailLoadingCallback)(C.ULFailLoadingCallback_55ff90b8), nil
}

func (x ULFailLoadingCallback) PassValue() (ref C.ULFailLoadingCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFailLoadingCallback55FF90B8Func == nil {
		uLFailLoadingCallback55FF90B8Func = x
	}
	return (C.ULFailLoadingCallback)(C.ULFailLoadingCallback_55ff90b8), nil
}

func NewULFailLoadingCallbackRef(ref unsafe.Pointer) *ULFailLoadingCallback {
	return (*ULFailLoadingCallback)(ref)
}

//export uLFailLoadingCallback55FF90B8
func uLFailLoadingCallback55FF90B8(cuserData unsafe.Pointer, ccaller C.ULView, cframeId C.ulonglong, cisMainFrame C._Bool, curl C.ULString, cdescription C.ULString, cerrorDomain C.ULString, cerrorCode C.int) {
	if uLFailLoadingCallback55FF90B8Func != nil {
		userData55ff90b8 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		caller55ff90b8 := *(*ULView)(unsafe.Pointer(&ccaller))
		frameId55ff90b8 := (uint64)(cframeId)
		isMainFrame55ff90b8 := (bool)(cisMainFrame)
		url55ff90b8 := *(*ULString)(unsafe.Pointer(&curl))
		description55ff90b8 := *(*ULString)(unsafe.Pointer(&cdescription))
		errorDomain55ff90b8 := *(*ULString)(unsafe.Pointer(&cerrorDomain))
		errorCode55ff90b8 := (int32)(cerrorCode)
		uLFailLoadingCallback55FF90B8Func(userData55ff90b8, caller55ff90b8, frameId55ff90b8, isMainFrame55ff90b8, url55ff90b8, description55ff90b8, errorDomain55ff90b8, errorCode55ff90b8)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLFailLoadingCallback55FF90B8Func ULFailLoadingCallback

func (x ULWindowObjectReadyCallback) PassRef() (ref *C.ULWindowObjectReadyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLWindowObjectReadyCallback66DC25F3Func == nil {
		uLWindowObjectReadyCallback66DC25F3Func = x
	}
	return (*C.ULWindowObjectReadyCallback)(C.ULWindowObjectReadyCallback_66dc25f3), nil
}

func (x ULWindowObjectReadyCallback) PassValue() (ref C.ULWindowObjectReadyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLWindowObjectReadyCallback66DC25F3Func == nil {
		uLWindowObjectReadyCallback66DC25F3Func = x
	}
	return (C.ULWindowObjectReadyCallback)(C.ULWindowObjectReadyCallback_66dc25f3), nil
}

func NewULWindowObjectReadyCallbackRef(ref unsafe.Pointer) *ULWindowObjectReadyCallback {
	return (*ULWindowObjectReadyCallback)(ref)
}

//export uLWindowObjectReadyCallback66DC25F3
func uLWindowObjectReadyCallback66DC25F3(cuserData unsafe.Pointer, ccaller C.ULView, cframeId C.ulonglong, cisMainFrame C._Bool, curl C.ULString) {
	if uLWindowObjectReadyCallback66DC25F3Func != nil {
		userData66dc25f3 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		caller66dc25f3 := *(*ULView)(unsafe.Pointer(&ccaller))
		frameId66dc25f3 := (uint64)(cframeId)
		isMainFrame66dc25f3 := (bool)(cisMainFrame)
		url66dc25f3 := *(*ULString)(unsafe.Pointer(&curl))
		uLWindowObjectReadyCallback66DC25F3Func(userData66dc25f3, caller66dc25f3, frameId66dc25f3, isMainFrame66dc25f3, url66dc25f3)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLWindowObjectReadyCallback66DC25F3Func ULWindowObjectReadyCallback

func (x ULDOMReadyCallback) PassRef() (ref *C.ULDOMReadyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLDOMReadyCallback6432C207Func == nil {
		uLDOMReadyCallback6432C207Func = x
	}
	return (*C.ULDOMReadyCallback)(C.ULDOMReadyCallback_6432c207), nil
}

func (x ULDOMReadyCallback) PassValue() (ref C.ULDOMReadyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLDOMReadyCallback6432C207Func == nil {
		uLDOMReadyCallback6432C207Func = x
	}
	return (C.ULDOMReadyCallback)(C.ULDOMReadyCallback_6432c207), nil
}

func NewULDOMReadyCallbackRef(ref unsafe.Pointer) *ULDOMReadyCallback {
	return (*ULDOMReadyCallback)(ref)
}

//export uLDOMReadyCallback6432C207
func uLDOMReadyCallback6432C207(cuserData unsafe.Pointer, ccaller C.ULView, cframeId C.ulonglong, cisMainFrame C._Bool, curl C.ULString) {
	if uLDOMReadyCallback6432C207Func != nil {
		userData6432c207 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		caller6432c207 := *(*ULView)(unsafe.Pointer(&ccaller))
		frameId6432c207 := (uint64)(cframeId)
		isMainFrame6432c207 := (bool)(cisMainFrame)
		url6432c207 := *(*ULString)(unsafe.Pointer(&curl))
		uLDOMReadyCallback6432C207Func(userData6432c207, caller6432c207, frameId6432c207, isMainFrame6432c207, url6432c207)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLDOMReadyCallback6432C207Func ULDOMReadyCallback

func (x ULUpdateHistoryCallback) PassRef() (ref *C.ULUpdateHistoryCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLUpdateHistoryCallback6E105364Func == nil {
		uLUpdateHistoryCallback6E105364Func = x
	}
	return (*C.ULUpdateHistoryCallback)(C.ULUpdateHistoryCallback_6e105364), nil
}

func (x ULUpdateHistoryCallback) PassValue() (ref C.ULUpdateHistoryCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLUpdateHistoryCallback6E105364Func == nil {
		uLUpdateHistoryCallback6E105364Func = x
	}
	return (C.ULUpdateHistoryCallback)(C.ULUpdateHistoryCallback_6e105364), nil
}

func NewULUpdateHistoryCallbackRef(ref unsafe.Pointer) *ULUpdateHistoryCallback {
	return (*ULUpdateHistoryCallback)(ref)
}

//export uLUpdateHistoryCallback6E105364
func uLUpdateHistoryCallback6E105364(cuserData unsafe.Pointer, ccaller C.ULView) {
	if uLUpdateHistoryCallback6E105364Func != nil {
		userData6e105364 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		caller6e105364 := *(*ULView)(unsafe.Pointer(&ccaller))
		uLUpdateHistoryCallback6E105364Func(userData6e105364, caller6e105364)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLUpdateHistoryCallback6E105364Func ULUpdateHistoryCallback

func (x ULSurfaceDefinitionCreateCallback) PassRef() (ref *C.ULSurfaceDefinitionCreateCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionCreateCallback573EC115Func == nil {
		uLSurfaceDefinitionCreateCallback573EC115Func = x
	}
	return (*C.ULSurfaceDefinitionCreateCallback)(C.ULSurfaceDefinitionCreateCallback_573ec115), nil
}

func (x ULSurfaceDefinitionCreateCallback) PassValue() (ref C.ULSurfaceDefinitionCreateCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionCreateCallback573EC115Func == nil {
		uLSurfaceDefinitionCreateCallback573EC115Func = x
	}
	return (C.ULSurfaceDefinitionCreateCallback)(C.ULSurfaceDefinitionCreateCallback_573ec115), nil
}

func NewULSurfaceDefinitionCreateCallbackRef(ref unsafe.Pointer) *ULSurfaceDefinitionCreateCallback {
	return (*ULSurfaceDefinitionCreateCallback)(ref)
}

//export uLSurfaceDefinitionCreateCallback573EC115
func uLSurfaceDefinitionCreateCallback573EC115(cwidth C.uint, cheight C.uint) unsafe.Pointer {
	if uLSurfaceDefinitionCreateCallback573EC115Func != nil {
		width573ec115 := (uint32)(cwidth)
		height573ec115 := (uint32)(cheight)
		ret573ec115 := uLSurfaceDefinitionCreateCallback573EC115Func(width573ec115, height573ec115)
		ret, _ := ret573ec115, cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLSurfaceDefinitionCreateCallback573EC115Func ULSurfaceDefinitionCreateCallback

func (x ULSurfaceDefinitionDestroyCallback) PassRef() (ref *C.ULSurfaceDefinitionDestroyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionDestroyCallback851BACEEFunc == nil {
		uLSurfaceDefinitionDestroyCallback851BACEEFunc = x
	}
	return (*C.ULSurfaceDefinitionDestroyCallback)(C.ULSurfaceDefinitionDestroyCallback_851bacee), nil
}

func (x ULSurfaceDefinitionDestroyCallback) PassValue() (ref C.ULSurfaceDefinitionDestroyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionDestroyCallback851BACEEFunc == nil {
		uLSurfaceDefinitionDestroyCallback851BACEEFunc = x
	}
	return (C.ULSurfaceDefinitionDestroyCallback)(C.ULSurfaceDefinitionDestroyCallback_851bacee), nil
}

func NewULSurfaceDefinitionDestroyCallbackRef(ref unsafe.Pointer) *ULSurfaceDefinitionDestroyCallback {
	return (*ULSurfaceDefinitionDestroyCallback)(ref)
}

//export uLSurfaceDefinitionDestroyCallback851BACEE
func uLSurfaceDefinitionDestroyCallback851BACEE(cuserData unsafe.Pointer) {
	if uLSurfaceDefinitionDestroyCallback851BACEEFunc != nil {
		userData851bacee := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		uLSurfaceDefinitionDestroyCallback851BACEEFunc(userData851bacee)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLSurfaceDefinitionDestroyCallback851BACEEFunc ULSurfaceDefinitionDestroyCallback

func (x ULSurfaceDefinitionGetWidthCallback) PassRef() (ref *C.ULSurfaceDefinitionGetWidthCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionGetWidthCallback1A49A8FDFunc == nil {
		uLSurfaceDefinitionGetWidthCallback1A49A8FDFunc = x
	}
	return (*C.ULSurfaceDefinitionGetWidthCallback)(C.ULSurfaceDefinitionGetWidthCallback_1a49a8fd), nil
}

func (x ULSurfaceDefinitionGetWidthCallback) PassValue() (ref C.ULSurfaceDefinitionGetWidthCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionGetWidthCallback1A49A8FDFunc == nil {
		uLSurfaceDefinitionGetWidthCallback1A49A8FDFunc = x
	}
	return (C.ULSurfaceDefinitionGetWidthCallback)(C.ULSurfaceDefinitionGetWidthCallback_1a49a8fd), nil
}

func NewULSurfaceDefinitionGetWidthCallbackRef(ref unsafe.Pointer) *ULSurfaceDefinitionGetWidthCallback {
	return (*ULSurfaceDefinitionGetWidthCallback)(ref)
}

//export uLSurfaceDefinitionGetWidthCallback1A49A8FD
func uLSurfaceDefinitionGetWidthCallback1A49A8FD(cuserData unsafe.Pointer) C.uint {
	if uLSurfaceDefinitionGetWidthCallback1A49A8FDFunc != nil {
		userData1a49a8fd := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		ret1a49a8fd := uLSurfaceDefinitionGetWidthCallback1A49A8FDFunc(userData1a49a8fd)
		ret, _ := (C.uint)(ret1a49a8fd), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLSurfaceDefinitionGetWidthCallback1A49A8FDFunc ULSurfaceDefinitionGetWidthCallback

func (x ULSurfaceDefinitionGetHeightCallback) PassRef() (ref *C.ULSurfaceDefinitionGetHeightCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionGetHeightCallback3E5FE408Func == nil {
		uLSurfaceDefinitionGetHeightCallback3E5FE408Func = x
	}
	return (*C.ULSurfaceDefinitionGetHeightCallback)(C.ULSurfaceDefinitionGetHeightCallback_3e5fe408), nil
}

func (x ULSurfaceDefinitionGetHeightCallback) PassValue() (ref C.ULSurfaceDefinitionGetHeightCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionGetHeightCallback3E5FE408Func == nil {
		uLSurfaceDefinitionGetHeightCallback3E5FE408Func = x
	}
	return (C.ULSurfaceDefinitionGetHeightCallback)(C.ULSurfaceDefinitionGetHeightCallback_3e5fe408), nil
}

func NewULSurfaceDefinitionGetHeightCallbackRef(ref unsafe.Pointer) *ULSurfaceDefinitionGetHeightCallback {
	return (*ULSurfaceDefinitionGetHeightCallback)(ref)
}

//export uLSurfaceDefinitionGetHeightCallback3E5FE408
func uLSurfaceDefinitionGetHeightCallback3E5FE408(cuserData unsafe.Pointer) C.uint {
	if uLSurfaceDefinitionGetHeightCallback3E5FE408Func != nil {
		userData3e5fe408 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		ret3e5fe408 := uLSurfaceDefinitionGetHeightCallback3E5FE408Func(userData3e5fe408)
		ret, _ := (C.uint)(ret3e5fe408), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLSurfaceDefinitionGetHeightCallback3E5FE408Func ULSurfaceDefinitionGetHeightCallback

func (x ULSurfaceDefinitionGetRowBytesCallback) PassRef() (ref *C.ULSurfaceDefinitionGetRowBytesCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionGetRowBytesCallbackADCC8668Func == nil {
		uLSurfaceDefinitionGetRowBytesCallbackADCC8668Func = x
	}
	return (*C.ULSurfaceDefinitionGetRowBytesCallback)(C.ULSurfaceDefinitionGetRowBytesCallback_adcc8668), nil
}

func (x ULSurfaceDefinitionGetRowBytesCallback) PassValue() (ref C.ULSurfaceDefinitionGetRowBytesCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionGetRowBytesCallbackADCC8668Func == nil {
		uLSurfaceDefinitionGetRowBytesCallbackADCC8668Func = x
	}
	return (C.ULSurfaceDefinitionGetRowBytesCallback)(C.ULSurfaceDefinitionGetRowBytesCallback_adcc8668), nil
}

func NewULSurfaceDefinitionGetRowBytesCallbackRef(ref unsafe.Pointer) *ULSurfaceDefinitionGetRowBytesCallback {
	return (*ULSurfaceDefinitionGetRowBytesCallback)(ref)
}

//export uLSurfaceDefinitionGetRowBytesCallbackADCC8668
func uLSurfaceDefinitionGetRowBytesCallbackADCC8668(cuserData unsafe.Pointer) C.uint {
	if uLSurfaceDefinitionGetRowBytesCallbackADCC8668Func != nil {
		userDataadcc8668 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		retadcc8668 := uLSurfaceDefinitionGetRowBytesCallbackADCC8668Func(userDataadcc8668)
		ret, _ := (C.uint)(retadcc8668), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLSurfaceDefinitionGetRowBytesCallbackADCC8668Func ULSurfaceDefinitionGetRowBytesCallback

func (x ULSurfaceDefinitionGetSizeCallback) PassRef() (ref *C.ULSurfaceDefinitionGetSizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionGetSizeCallback83184AFEFunc == nil {
		uLSurfaceDefinitionGetSizeCallback83184AFEFunc = x
	}
	return (*C.ULSurfaceDefinitionGetSizeCallback)(C.ULSurfaceDefinitionGetSizeCallback_83184afe), nil
}

func (x ULSurfaceDefinitionGetSizeCallback) PassValue() (ref C.ULSurfaceDefinitionGetSizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionGetSizeCallback83184AFEFunc == nil {
		uLSurfaceDefinitionGetSizeCallback83184AFEFunc = x
	}
	return (C.ULSurfaceDefinitionGetSizeCallback)(C.ULSurfaceDefinitionGetSizeCallback_83184afe), nil
}

func NewULSurfaceDefinitionGetSizeCallbackRef(ref unsafe.Pointer) *ULSurfaceDefinitionGetSizeCallback {
	return (*ULSurfaceDefinitionGetSizeCallback)(ref)
}

//export uLSurfaceDefinitionGetSizeCallback83184AFE
func uLSurfaceDefinitionGetSizeCallback83184AFE(cuserData unsafe.Pointer) C.size_t {
	if uLSurfaceDefinitionGetSizeCallback83184AFEFunc != nil {
		userData83184afe := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		ret83184afe := uLSurfaceDefinitionGetSizeCallback83184AFEFunc(userData83184afe)
		ret, _ := (C.size_t)(ret83184afe), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLSurfaceDefinitionGetSizeCallback83184AFEFunc ULSurfaceDefinitionGetSizeCallback

func (x ULSurfaceDefinitionLockPixelsCallback) PassRef() (ref *C.ULSurfaceDefinitionLockPixelsCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionLockPixelsCallback7763E12FFunc == nil {
		uLSurfaceDefinitionLockPixelsCallback7763E12FFunc = x
	}
	return (*C.ULSurfaceDefinitionLockPixelsCallback)(C.ULSurfaceDefinitionLockPixelsCallback_7763e12f), nil
}

func (x ULSurfaceDefinitionLockPixelsCallback) PassValue() (ref C.ULSurfaceDefinitionLockPixelsCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionLockPixelsCallback7763E12FFunc == nil {
		uLSurfaceDefinitionLockPixelsCallback7763E12FFunc = x
	}
	return (C.ULSurfaceDefinitionLockPixelsCallback)(C.ULSurfaceDefinitionLockPixelsCallback_7763e12f), nil
}

func NewULSurfaceDefinitionLockPixelsCallbackRef(ref unsafe.Pointer) *ULSurfaceDefinitionLockPixelsCallback {
	return (*ULSurfaceDefinitionLockPixelsCallback)(ref)
}

//export uLSurfaceDefinitionLockPixelsCallback7763E12F
func uLSurfaceDefinitionLockPixelsCallback7763E12F(cuserData unsafe.Pointer) unsafe.Pointer {
	if uLSurfaceDefinitionLockPixelsCallback7763E12FFunc != nil {
		userData7763e12f := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		ret7763e12f := uLSurfaceDefinitionLockPixelsCallback7763E12FFunc(userData7763e12f)
		ret, _ := ret7763e12f, cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLSurfaceDefinitionLockPixelsCallback7763E12FFunc ULSurfaceDefinitionLockPixelsCallback

func (x ULSurfaceDefinitionUnlockPixelsCallback) PassRef() (ref *C.ULSurfaceDefinitionUnlockPixelsCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionUnlockPixelsCallbackD4B69F9Func == nil {
		uLSurfaceDefinitionUnlockPixelsCallbackD4B69F9Func = x
	}
	return (*C.ULSurfaceDefinitionUnlockPixelsCallback)(C.ULSurfaceDefinitionUnlockPixelsCallback_d4b69f9), nil
}

func (x ULSurfaceDefinitionUnlockPixelsCallback) PassValue() (ref C.ULSurfaceDefinitionUnlockPixelsCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionUnlockPixelsCallbackD4B69F9Func == nil {
		uLSurfaceDefinitionUnlockPixelsCallbackD4B69F9Func = x
	}
	return (C.ULSurfaceDefinitionUnlockPixelsCallback)(C.ULSurfaceDefinitionUnlockPixelsCallback_d4b69f9), nil
}

func NewULSurfaceDefinitionUnlockPixelsCallbackRef(ref unsafe.Pointer) *ULSurfaceDefinitionUnlockPixelsCallback {
	return (*ULSurfaceDefinitionUnlockPixelsCallback)(ref)
}

//export uLSurfaceDefinitionUnlockPixelsCallbackD4B69F9
func uLSurfaceDefinitionUnlockPixelsCallbackD4B69F9(cuserData unsafe.Pointer) {
	if uLSurfaceDefinitionUnlockPixelsCallbackD4B69F9Func != nil {
		userDatad4b69f9 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		uLSurfaceDefinitionUnlockPixelsCallbackD4B69F9Func(userDatad4b69f9)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLSurfaceDefinitionUnlockPixelsCallbackD4B69F9Func ULSurfaceDefinitionUnlockPixelsCallback

func (x ULSurfaceDefinitionResizeCallback) PassRef() (ref *C.ULSurfaceDefinitionResizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionResizeCallback22D82567Func == nil {
		uLSurfaceDefinitionResizeCallback22D82567Func = x
	}
	return (*C.ULSurfaceDefinitionResizeCallback)(C.ULSurfaceDefinitionResizeCallback_22d82567), nil
}

func (x ULSurfaceDefinitionResizeCallback) PassValue() (ref C.ULSurfaceDefinitionResizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLSurfaceDefinitionResizeCallback22D82567Func == nil {
		uLSurfaceDefinitionResizeCallback22D82567Func = x
	}
	return (C.ULSurfaceDefinitionResizeCallback)(C.ULSurfaceDefinitionResizeCallback_22d82567), nil
}

func NewULSurfaceDefinitionResizeCallbackRef(ref unsafe.Pointer) *ULSurfaceDefinitionResizeCallback {
	return (*ULSurfaceDefinitionResizeCallback)(ref)
}

//export uLSurfaceDefinitionResizeCallback22D82567
func uLSurfaceDefinitionResizeCallback22D82567(cuserData unsafe.Pointer, cwidth C.uint, cheight C.uint) {
	if uLSurfaceDefinitionResizeCallback22D82567Func != nil {
		userData22d82567 := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		width22d82567 := (uint32)(cwidth)
		height22d82567 := (uint32)(cheight)
		uLSurfaceDefinitionResizeCallback22D82567Func(userData22d82567, width22d82567, height22d82567)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLSurfaceDefinitionResizeCallback22D82567Func ULSurfaceDefinitionResizeCallback

// allocULSurfaceDefinitionMemory allocates memory for type C.ULSurfaceDefinition in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULSurfaceDefinitionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULSurfaceDefinitionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULSurfaceDefinitionValue = unsafe.Sizeof([1]C.ULSurfaceDefinition{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULSurfaceDefinition) Ref() *C.ULSurfaceDefinition {
	if x == nil {
		return nil
	}
	return x.ref13063f1a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULSurfaceDefinition) Free() {
	if x != nil && x.allocs13063f1a != nil {
		x.allocs13063f1a.(*cgoAllocMap).Free()
		x.ref13063f1a = nil
	}
}

// NewULSurfaceDefinitionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULSurfaceDefinitionRef(ref unsafe.Pointer) *ULSurfaceDefinition {
	if ref == nil {
		return nil
	}
	obj := new(ULSurfaceDefinition)
	obj.ref13063f1a = (*C.ULSurfaceDefinition)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULSurfaceDefinition) PassRef() (*C.ULSurfaceDefinition, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref13063f1a != nil {
		return x.ref13063f1a, nil
	}
	mem13063f1a := allocULSurfaceDefinitionMemory(1)
	ref13063f1a := (*C.ULSurfaceDefinition)(mem13063f1a)
	allocs13063f1a := new(cgoAllocMap)
	allocs13063f1a.Add(mem13063f1a)

	var ccreate_allocs *cgoAllocMap
	ref13063f1a.create, ccreate_allocs = x.Create.PassValue()
	allocs13063f1a.Borrow(ccreate_allocs)

	var cdestroy_allocs *cgoAllocMap
	ref13063f1a.destroy, cdestroy_allocs = x.Destroy.PassValue()
	allocs13063f1a.Borrow(cdestroy_allocs)

	var cget_width_allocs *cgoAllocMap
	ref13063f1a.get_width, cget_width_allocs = x.GetWidth.PassValue()
	allocs13063f1a.Borrow(cget_width_allocs)

	var cget_height_allocs *cgoAllocMap
	ref13063f1a.get_height, cget_height_allocs = x.GetHeight.PassValue()
	allocs13063f1a.Borrow(cget_height_allocs)

	var cget_row_bytes_allocs *cgoAllocMap
	ref13063f1a.get_row_bytes, cget_row_bytes_allocs = x.GetRowBytes.PassValue()
	allocs13063f1a.Borrow(cget_row_bytes_allocs)

	var cget_size_allocs *cgoAllocMap
	ref13063f1a.get_size, cget_size_allocs = x.GetSize.PassValue()
	allocs13063f1a.Borrow(cget_size_allocs)

	var clock_pixels_allocs *cgoAllocMap
	ref13063f1a.lock_pixels, clock_pixels_allocs = x.LockPixels.PassValue()
	allocs13063f1a.Borrow(clock_pixels_allocs)

	var cunlock_pixels_allocs *cgoAllocMap
	ref13063f1a.unlock_pixels, cunlock_pixels_allocs = x.UnlockPixels.PassValue()
	allocs13063f1a.Borrow(cunlock_pixels_allocs)

	var cresize_allocs *cgoAllocMap
	ref13063f1a.resize, cresize_allocs = x.Resize.PassValue()
	allocs13063f1a.Borrow(cresize_allocs)

	x.ref13063f1a = ref13063f1a
	x.allocs13063f1a = allocs13063f1a
	return ref13063f1a, allocs13063f1a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULSurfaceDefinition) PassValue() (C.ULSurfaceDefinition, *cgoAllocMap) {
	if x.ref13063f1a != nil {
		return *x.ref13063f1a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULSurfaceDefinition) Deref() {
	if x.ref13063f1a == nil {
		return
	}
	x.Create = *NewULSurfaceDefinitionCreateCallbackRef(unsafe.Pointer(&x.ref13063f1a.create))
	x.Destroy = *NewULSurfaceDefinitionDestroyCallbackRef(unsafe.Pointer(&x.ref13063f1a.destroy))
	x.GetWidth = *NewULSurfaceDefinitionGetWidthCallbackRef(unsafe.Pointer(&x.ref13063f1a.get_width))
	x.GetHeight = *NewULSurfaceDefinitionGetHeightCallbackRef(unsafe.Pointer(&x.ref13063f1a.get_height))
	x.GetRowBytes = *NewULSurfaceDefinitionGetRowBytesCallbackRef(unsafe.Pointer(&x.ref13063f1a.get_row_bytes))
	x.GetSize = *NewULSurfaceDefinitionGetSizeCallbackRef(unsafe.Pointer(&x.ref13063f1a.get_size))
	x.LockPixels = *NewULSurfaceDefinitionLockPixelsCallbackRef(unsafe.Pointer(&x.ref13063f1a.lock_pixels))
	x.UnlockPixels = *NewULSurfaceDefinitionUnlockPixelsCallbackRef(unsafe.Pointer(&x.ref13063f1a.unlock_pixels))
	x.Resize = *NewULSurfaceDefinitionResizeCallbackRef(unsafe.Pointer(&x.ref13063f1a.resize))
}

func (x ULFileSystemFileExistsCallback) PassRef() (ref *C.ULFileSystemFileExistsCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemFileExistsCallbackD03BF100Func == nil {
		uLFileSystemFileExistsCallbackD03BF100Func = x
	}
	return (*C.ULFileSystemFileExistsCallback)(C.ULFileSystemFileExistsCallback_d03bf100), nil
}

func (x ULFileSystemFileExistsCallback) PassValue() (ref C.ULFileSystemFileExistsCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemFileExistsCallbackD03BF100Func == nil {
		uLFileSystemFileExistsCallbackD03BF100Func = x
	}
	return (C.ULFileSystemFileExistsCallback)(C.ULFileSystemFileExistsCallback_d03bf100), nil
}

func NewULFileSystemFileExistsCallbackRef(ref unsafe.Pointer) *ULFileSystemFileExistsCallback {
	return (*ULFileSystemFileExistsCallback)(ref)
}

//export uLFileSystemFileExistsCallbackD03BF100
func uLFileSystemFileExistsCallbackD03BF100(cpath C.ULString) C._Bool {
	if uLFileSystemFileExistsCallbackD03BF100Func != nil {
		pathd03bf100 := *(*ULString)(unsafe.Pointer(&cpath))
		retd03bf100 := uLFileSystemFileExistsCallbackD03BF100Func(pathd03bf100)
		ret, _ := (C._Bool)(retd03bf100), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLFileSystemFileExistsCallbackD03BF100Func ULFileSystemFileExistsCallback

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

func (x ULFileSystemGetFileSizeCallback) PassRef() (ref *C.ULFileSystemGetFileSizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemGetFileSizeCallbackE87AD8B1Func == nil {
		uLFileSystemGetFileSizeCallbackE87AD8B1Func = x
	}
	return (*C.ULFileSystemGetFileSizeCallback)(C.ULFileSystemGetFileSizeCallback_e87ad8b1), nil
}

func (x ULFileSystemGetFileSizeCallback) PassValue() (ref C.ULFileSystemGetFileSizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemGetFileSizeCallbackE87AD8B1Func == nil {
		uLFileSystemGetFileSizeCallbackE87AD8B1Func = x
	}
	return (C.ULFileSystemGetFileSizeCallback)(C.ULFileSystemGetFileSizeCallback_e87ad8b1), nil
}

func NewULFileSystemGetFileSizeCallbackRef(ref unsafe.Pointer) *ULFileSystemGetFileSizeCallback {
	return (*ULFileSystemGetFileSizeCallback)(ref)
}

//export uLFileSystemGetFileSizeCallbackE87AD8B1
func uLFileSystemGetFileSizeCallbackE87AD8B1(chandle C.ULFileHandle, cresult *C.longlong) C._Bool {
	if uLFileSystemGetFileSizeCallbackE87AD8B1Func != nil {
		handlee87ad8b1 := (ULFileHandle)(chandle)
		var resulte87ad8b1 []int64
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&resulte87ad8b1))
		hxfc4425b.Data = unsafe.Pointer(cresult)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?

		rete87ad8b1 := uLFileSystemGetFileSizeCallbackE87AD8B1Func(handlee87ad8b1, resulte87ad8b1)
		ret, _ := (C._Bool)(rete87ad8b1), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLFileSystemGetFileSizeCallbackE87AD8B1Func ULFileSystemGetFileSizeCallback

func (x ULFileSystemGetFileMimeTypeCallback) PassRef() (ref *C.ULFileSystemGetFileMimeTypeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemGetFileMimeTypeCallback7E6FD322Func == nil {
		uLFileSystemGetFileMimeTypeCallback7E6FD322Func = x
	}
	return (*C.ULFileSystemGetFileMimeTypeCallback)(C.ULFileSystemGetFileMimeTypeCallback_7e6fd322), nil
}

func (x ULFileSystemGetFileMimeTypeCallback) PassValue() (ref C.ULFileSystemGetFileMimeTypeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemGetFileMimeTypeCallback7E6FD322Func == nil {
		uLFileSystemGetFileMimeTypeCallback7E6FD322Func = x
	}
	return (C.ULFileSystemGetFileMimeTypeCallback)(C.ULFileSystemGetFileMimeTypeCallback_7e6fd322), nil
}

func NewULFileSystemGetFileMimeTypeCallbackRef(ref unsafe.Pointer) *ULFileSystemGetFileMimeTypeCallback {
	return (*ULFileSystemGetFileMimeTypeCallback)(ref)
}

//export uLFileSystemGetFileMimeTypeCallback7E6FD322
func uLFileSystemGetFileMimeTypeCallback7E6FD322(cpath C.ULString, cresult C.ULString) C._Bool {
	if uLFileSystemGetFileMimeTypeCallback7E6FD322Func != nil {
		path7e6fd322 := *(*ULString)(unsafe.Pointer(&cpath))
		result7e6fd322 := *(*ULString)(unsafe.Pointer(&cresult))
		ret7e6fd322 := uLFileSystemGetFileMimeTypeCallback7E6FD322Func(path7e6fd322, result7e6fd322)
		ret, _ := (C._Bool)(ret7e6fd322), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLFileSystemGetFileMimeTypeCallback7E6FD322Func ULFileSystemGetFileMimeTypeCallback

func (x ULFileSystemOpenFileCallback) PassRef() (ref *C.ULFileSystemOpenFileCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemOpenFileCallbackBBB19604Func == nil {
		uLFileSystemOpenFileCallbackBBB19604Func = x
	}
	return (*C.ULFileSystemOpenFileCallback)(C.ULFileSystemOpenFileCallback_bbb19604), nil
}

func (x ULFileSystemOpenFileCallback) PassValue() (ref C.ULFileSystemOpenFileCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemOpenFileCallbackBBB19604Func == nil {
		uLFileSystemOpenFileCallbackBBB19604Func = x
	}
	return (C.ULFileSystemOpenFileCallback)(C.ULFileSystemOpenFileCallback_bbb19604), nil
}

func NewULFileSystemOpenFileCallbackRef(ref unsafe.Pointer) *ULFileSystemOpenFileCallback {
	return (*ULFileSystemOpenFileCallback)(ref)
}

//export uLFileSystemOpenFileCallbackBBB19604
func uLFileSystemOpenFileCallbackBBB19604(cpath C.ULString, copenForWriting C._Bool) C.ULFileHandle {
	if uLFileSystemOpenFileCallbackBBB19604Func != nil {
		pathbbb19604 := *(*ULString)(unsafe.Pointer(&cpath))
		openForWritingbbb19604 := (bool)(copenForWriting)
		retbbb19604 := uLFileSystemOpenFileCallbackBBB19604Func(pathbbb19604, openForWritingbbb19604)
		ret, _ := (C.ULFileHandle)(retbbb19604), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLFileSystemOpenFileCallbackBBB19604Func ULFileSystemOpenFileCallback

func (x ULFileSystemCloseFileCallback) PassRef() (ref *C.ULFileSystemCloseFileCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemCloseFileCallbackC90AC2E5Func == nil {
		uLFileSystemCloseFileCallbackC90AC2E5Func = x
	}
	return (*C.ULFileSystemCloseFileCallback)(C.ULFileSystemCloseFileCallback_c90ac2e5), nil
}

func (x ULFileSystemCloseFileCallback) PassValue() (ref C.ULFileSystemCloseFileCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemCloseFileCallbackC90AC2E5Func == nil {
		uLFileSystemCloseFileCallbackC90AC2E5Func = x
	}
	return (C.ULFileSystemCloseFileCallback)(C.ULFileSystemCloseFileCallback_c90ac2e5), nil
}

func NewULFileSystemCloseFileCallbackRef(ref unsafe.Pointer) *ULFileSystemCloseFileCallback {
	return (*ULFileSystemCloseFileCallback)(ref)
}

//export uLFileSystemCloseFileCallbackC90AC2E5
func uLFileSystemCloseFileCallbackC90AC2E5(chandle C.ULFileHandle) {
	if uLFileSystemCloseFileCallbackC90AC2E5Func != nil {
		handlec90ac2e5 := (ULFileHandle)(chandle)
		uLFileSystemCloseFileCallbackC90AC2E5Func(handlec90ac2e5)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLFileSystemCloseFileCallbackC90AC2E5Func ULFileSystemCloseFileCallback

func (x ULFileSystemReadFromFileCallback) PassRef() (ref *C.ULFileSystemReadFromFileCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemReadFromFileCallbackBC1997BCFunc == nil {
		uLFileSystemReadFromFileCallbackBC1997BCFunc = x
	}
	return (*C.ULFileSystemReadFromFileCallback)(C.ULFileSystemReadFromFileCallback_bc1997bc), nil
}

func (x ULFileSystemReadFromFileCallback) PassValue() (ref C.ULFileSystemReadFromFileCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFileSystemReadFromFileCallbackBC1997BCFunc == nil {
		uLFileSystemReadFromFileCallbackBC1997BCFunc = x
	}
	return (C.ULFileSystemReadFromFileCallback)(C.ULFileSystemReadFromFileCallback_bc1997bc), nil
}

func NewULFileSystemReadFromFileCallbackRef(ref unsafe.Pointer) *ULFileSystemReadFromFileCallback {
	return (*ULFileSystemReadFromFileCallback)(ref)
}

//export uLFileSystemReadFromFileCallbackBC1997BC
func uLFileSystemReadFromFileCallbackBC1997BC(chandle C.ULFileHandle, cdata *C.char, clength C.longlong) C.longlong {
	if uLFileSystemReadFromFileCallbackBC1997BCFunc != nil {
		handlebc1997bc := (ULFileHandle)(chandle)
		var databc1997bc []byte
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&databc1997bc))
		hxf95e7c8.Data = unsafe.Pointer(cdata)
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?

		lengthbc1997bc := (int64)(clength)
		retbc1997bc := uLFileSystemReadFromFileCallbackBC1997BCFunc(handlebc1997bc, databc1997bc, lengthbc1997bc)
		ret, _ := (C.longlong)(retbc1997bc), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLFileSystemReadFromFileCallbackBC1997BCFunc ULFileSystemReadFromFileCallback

// allocULFileSystemMemory allocates memory for type C.ULFileSystem in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULFileSystemMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULFileSystemValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULFileSystemValue = unsafe.Sizeof([1]C.ULFileSystem{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULFileSystem) Ref() *C.ULFileSystem {
	if x == nil {
		return nil
	}
	return x.ref41d243eb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULFileSystem) Free() {
	if x != nil && x.allocs41d243eb != nil {
		x.allocs41d243eb.(*cgoAllocMap).Free()
		x.ref41d243eb = nil
	}
}

// NewULFileSystemRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULFileSystemRef(ref unsafe.Pointer) *ULFileSystem {
	if ref == nil {
		return nil
	}
	obj := new(ULFileSystem)
	obj.ref41d243eb = (*C.ULFileSystem)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULFileSystem) PassRef() (*C.ULFileSystem, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref41d243eb != nil {
		return x.ref41d243eb, nil
	}
	mem41d243eb := allocULFileSystemMemory(1)
	ref41d243eb := (*C.ULFileSystem)(mem41d243eb)
	allocs41d243eb := new(cgoAllocMap)
	allocs41d243eb.Add(mem41d243eb)

	var cfile_exists_allocs *cgoAllocMap
	ref41d243eb.file_exists, cfile_exists_allocs = x.FileExists.PassValue()
	allocs41d243eb.Borrow(cfile_exists_allocs)

	var cget_file_size_allocs *cgoAllocMap
	ref41d243eb.get_file_size, cget_file_size_allocs = x.GetFileSize.PassValue()
	allocs41d243eb.Borrow(cget_file_size_allocs)

	var cget_file_mime_type_allocs *cgoAllocMap
	ref41d243eb.get_file_mime_type, cget_file_mime_type_allocs = x.GetFileMimeType.PassValue()
	allocs41d243eb.Borrow(cget_file_mime_type_allocs)

	var copen_file_allocs *cgoAllocMap
	ref41d243eb.open_file, copen_file_allocs = x.OpenFile.PassValue()
	allocs41d243eb.Borrow(copen_file_allocs)

	var cclose_file_allocs *cgoAllocMap
	ref41d243eb.close_file, cclose_file_allocs = x.CloseFile.PassValue()
	allocs41d243eb.Borrow(cclose_file_allocs)

	var cread_from_file_allocs *cgoAllocMap
	ref41d243eb.read_from_file, cread_from_file_allocs = x.ReadFromFile.PassValue()
	allocs41d243eb.Borrow(cread_from_file_allocs)

	x.ref41d243eb = ref41d243eb
	x.allocs41d243eb = allocs41d243eb
	return ref41d243eb, allocs41d243eb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULFileSystem) PassValue() (C.ULFileSystem, *cgoAllocMap) {
	if x.ref41d243eb != nil {
		return *x.ref41d243eb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULFileSystem) Deref() {
	if x.ref41d243eb == nil {
		return
	}
	x.FileExists = *NewULFileSystemFileExistsCallbackRef(unsafe.Pointer(&x.ref41d243eb.file_exists))
	x.GetFileSize = *NewULFileSystemGetFileSizeCallbackRef(unsafe.Pointer(&x.ref41d243eb.get_file_size))
	x.GetFileMimeType = *NewULFileSystemGetFileMimeTypeCallbackRef(unsafe.Pointer(&x.ref41d243eb.get_file_mime_type))
	x.OpenFile = *NewULFileSystemOpenFileCallbackRef(unsafe.Pointer(&x.ref41d243eb.open_file))
	x.CloseFile = *NewULFileSystemCloseFileCallbackRef(unsafe.Pointer(&x.ref41d243eb.close_file))
	x.ReadFromFile = *NewULFileSystemReadFromFileCallbackRef(unsafe.Pointer(&x.ref41d243eb.read_from_file))
}

func (x ULLoggerLogMessageCallback) PassRef() (ref *C.ULLoggerLogMessageCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLLoggerLogMessageCallback454E682AFunc == nil {
		uLLoggerLogMessageCallback454E682AFunc = x
	}
	return (*C.ULLoggerLogMessageCallback)(C.ULLoggerLogMessageCallback_454e682a), nil
}

func (x ULLoggerLogMessageCallback) PassValue() (ref C.ULLoggerLogMessageCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLLoggerLogMessageCallback454E682AFunc == nil {
		uLLoggerLogMessageCallback454E682AFunc = x
	}
	return (C.ULLoggerLogMessageCallback)(C.ULLoggerLogMessageCallback_454e682a), nil
}

func NewULLoggerLogMessageCallbackRef(ref unsafe.Pointer) *ULLoggerLogMessageCallback {
	return (*ULLoggerLogMessageCallback)(ref)
}

//export uLLoggerLogMessageCallback454E682A
func uLLoggerLogMessageCallback454E682A(clogLevel C.ULLogLevel, cmessage C.ULString) {
	if uLLoggerLogMessageCallback454E682AFunc != nil {
		logLevel454e682a := (ULLogLevel)(clogLevel)
		message454e682a := *(*ULString)(unsafe.Pointer(&cmessage))
		uLLoggerLogMessageCallback454E682AFunc(logLevel454e682a, message454e682a)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLLoggerLogMessageCallback454E682AFunc ULLoggerLogMessageCallback

// allocULLoggerMemory allocates memory for type C.ULLogger in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULLoggerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULLoggerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULLoggerValue = unsafe.Sizeof([1]C.ULLogger{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULLogger) Ref() *C.ULLogger {
	if x == nil {
		return nil
	}
	return x.refd55f8aa0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULLogger) Free() {
	if x != nil && x.allocsd55f8aa0 != nil {
		x.allocsd55f8aa0.(*cgoAllocMap).Free()
		x.refd55f8aa0 = nil
	}
}

// NewULLoggerRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULLoggerRef(ref unsafe.Pointer) *ULLogger {
	if ref == nil {
		return nil
	}
	obj := new(ULLogger)
	obj.refd55f8aa0 = (*C.ULLogger)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULLogger) PassRef() (*C.ULLogger, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd55f8aa0 != nil {
		return x.refd55f8aa0, nil
	}
	memd55f8aa0 := allocULLoggerMemory(1)
	refd55f8aa0 := (*C.ULLogger)(memd55f8aa0)
	allocsd55f8aa0 := new(cgoAllocMap)
	allocsd55f8aa0.Add(memd55f8aa0)

	var clog_message_allocs *cgoAllocMap
	refd55f8aa0.log_message, clog_message_allocs = x.LogMessage.PassValue()
	allocsd55f8aa0.Borrow(clog_message_allocs)

	x.refd55f8aa0 = refd55f8aa0
	x.allocsd55f8aa0 = allocsd55f8aa0
	return refd55f8aa0, allocsd55f8aa0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULLogger) PassValue() (C.ULLogger, *cgoAllocMap) {
	if x.refd55f8aa0 != nil {
		return *x.refd55f8aa0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULLogger) Deref() {
	if x.refd55f8aa0 == nil {
		return
	}
	x.LogMessage = *NewULLoggerLogMessageCallbackRef(unsafe.Pointer(&x.refd55f8aa0.log_message))
}

// allocULRenderBufferMemory allocates memory for type C.ULRenderBuffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULRenderBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULRenderBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULRenderBufferValue = unsafe.Sizeof([1]C.ULRenderBuffer{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULRenderBuffer) Ref() *C.ULRenderBuffer {
	if x == nil {
		return nil
	}
	return x.refe8ed55f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULRenderBuffer) Free() {
	if x != nil && x.allocse8ed55f != nil {
		x.allocse8ed55f.(*cgoAllocMap).Free()
		x.refe8ed55f = nil
	}
}

// NewULRenderBufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULRenderBufferRef(ref unsafe.Pointer) *ULRenderBuffer {
	if ref == nil {
		return nil
	}
	obj := new(ULRenderBuffer)
	obj.refe8ed55f = (*C.ULRenderBuffer)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULRenderBuffer) PassRef() (*C.ULRenderBuffer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe8ed55f != nil {
		return x.refe8ed55f, nil
	}
	meme8ed55f := allocULRenderBufferMemory(1)
	refe8ed55f := (*C.ULRenderBuffer)(meme8ed55f)
	allocse8ed55f := new(cgoAllocMap)
	allocse8ed55f.Add(meme8ed55f)

	var ctexture_id_allocs *cgoAllocMap
	refe8ed55f.texture_id, ctexture_id_allocs = (C.uint)(x.TextureId), cgoAllocsUnknown
	allocse8ed55f.Borrow(ctexture_id_allocs)

	var cwidth_allocs *cgoAllocMap
	refe8ed55f.width, cwidth_allocs = (C.uint)(x.Width), cgoAllocsUnknown
	allocse8ed55f.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refe8ed55f.height, cheight_allocs = (C.uint)(x.Height), cgoAllocsUnknown
	allocse8ed55f.Borrow(cheight_allocs)

	var chas_stencil_buffer_allocs *cgoAllocMap
	refe8ed55f.has_stencil_buffer, chas_stencil_buffer_allocs = (C._Bool)(x.HasStencilBuffer), cgoAllocsUnknown
	allocse8ed55f.Borrow(chas_stencil_buffer_allocs)

	var chas_depth_buffer_allocs *cgoAllocMap
	refe8ed55f.has_depth_buffer, chas_depth_buffer_allocs = (C._Bool)(x.HasDepthBuffer), cgoAllocsUnknown
	allocse8ed55f.Borrow(chas_depth_buffer_allocs)

	x.refe8ed55f = refe8ed55f
	x.allocse8ed55f = allocse8ed55f
	return refe8ed55f, allocse8ed55f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULRenderBuffer) PassValue() (C.ULRenderBuffer, *cgoAllocMap) {
	if x.refe8ed55f != nil {
		return *x.refe8ed55f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULRenderBuffer) Deref() {
	if x.refe8ed55f == nil {
		return
	}
	x.TextureId = (uint32)(x.refe8ed55f.texture_id)
	x.Width = (uint32)(x.refe8ed55f.width)
	x.Height = (uint32)(x.refe8ed55f.height)
	x.HasStencilBuffer = (bool)(x.refe8ed55f.has_stencil_buffer)
	x.HasDepthBuffer = (bool)(x.refe8ed55f.has_depth_buffer)
}

// allocULVertex2f4ub2fMemory allocates memory for type C.ULVertex_2f_4ub_2f in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULVertex2f4ub2fMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULVertex2f4ub2fValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULVertex2f4ub2fValue = unsafe.Sizeof([1]C.ULVertex_2f_4ub_2f{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULVertex2f4ub2f) Ref() *C.ULVertex_2f_4ub_2f {
	if x == nil {
		return nil
	}
	return x.ref2acaf525
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULVertex2f4ub2f) Free() {
	if x != nil && x.allocs2acaf525 != nil {
		x.allocs2acaf525.(*cgoAllocMap).Free()
		x.ref2acaf525 = nil
	}
}

// NewULVertex2f4ub2fRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULVertex2f4ub2fRef(ref unsafe.Pointer) *ULVertex2f4ub2f {
	if ref == nil {
		return nil
	}
	obj := new(ULVertex2f4ub2f)
	obj.ref2acaf525 = (*C.ULVertex_2f_4ub_2f)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULVertex2f4ub2f) PassRef() (*C.ULVertex_2f_4ub_2f, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2acaf525 != nil {
		return x.ref2acaf525, nil
	}
	mem2acaf525 := allocULVertex2f4ub2fMemory(1)
	ref2acaf525 := (*C.ULVertex_2f_4ub_2f)(mem2acaf525)
	allocs2acaf525 := new(cgoAllocMap)
	allocs2acaf525.Add(mem2acaf525)

	var cpos_allocs *cgoAllocMap
	ref2acaf525.pos, cpos_allocs = *(*[2]C.float)(unsafe.Pointer(&x.Pos)), cgoAllocsUnknown
	allocs2acaf525.Borrow(cpos_allocs)

	var ccolor_allocs *cgoAllocMap
	ref2acaf525.color, ccolor_allocs = *(*[4]C.uchar)(unsafe.Pointer(&x.Color)), cgoAllocsUnknown
	allocs2acaf525.Borrow(ccolor_allocs)

	var cobj_allocs *cgoAllocMap
	ref2acaf525.obj, cobj_allocs = *(*[2]C.float)(unsafe.Pointer(&x.Obj)), cgoAllocsUnknown
	allocs2acaf525.Borrow(cobj_allocs)

	x.ref2acaf525 = ref2acaf525
	x.allocs2acaf525 = allocs2acaf525
	return ref2acaf525, allocs2acaf525

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULVertex2f4ub2f) PassValue() (C.ULVertex_2f_4ub_2f, *cgoAllocMap) {
	if x.ref2acaf525 != nil {
		return *x.ref2acaf525, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULVertex2f4ub2f) Deref() {
	if x.ref2acaf525 == nil {
		return
	}
	x.Pos = *(*[2]float32)(unsafe.Pointer(&x.ref2acaf525.pos))
	x.Color = *(*[4]byte)(unsafe.Pointer(&x.ref2acaf525.color))
	x.Obj = *(*[2]float32)(unsafe.Pointer(&x.ref2acaf525.obj))
}

// allocULVertex2f4ub2f2f28fMemory allocates memory for type C.ULVertex_2f_4ub_2f_2f_28f in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULVertex2f4ub2f2f28fMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULVertex2f4ub2f2f28fValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULVertex2f4ub2f2f28fValue = unsafe.Sizeof([1]C.ULVertex_2f_4ub_2f_2f_28f{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULVertex2f4ub2f2f28f) Ref() *C.ULVertex_2f_4ub_2f_2f_28f {
	if x == nil {
		return nil
	}
	return x.refa40e1546
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULVertex2f4ub2f2f28f) Free() {
	if x != nil && x.allocsa40e1546 != nil {
		x.allocsa40e1546.(*cgoAllocMap).Free()
		x.refa40e1546 = nil
	}
}

// NewULVertex2f4ub2f2f28fRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULVertex2f4ub2f2f28fRef(ref unsafe.Pointer) *ULVertex2f4ub2f2f28f {
	if ref == nil {
		return nil
	}
	obj := new(ULVertex2f4ub2f2f28f)
	obj.refa40e1546 = (*C.ULVertex_2f_4ub_2f_2f_28f)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULVertex2f4ub2f2f28f) PassRef() (*C.ULVertex_2f_4ub_2f_2f_28f, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa40e1546 != nil {
		return x.refa40e1546, nil
	}
	mema40e1546 := allocULVertex2f4ub2f2f28fMemory(1)
	refa40e1546 := (*C.ULVertex_2f_4ub_2f_2f_28f)(mema40e1546)
	allocsa40e1546 := new(cgoAllocMap)
	allocsa40e1546.Add(mema40e1546)

	var cpos_allocs *cgoAllocMap
	refa40e1546.pos, cpos_allocs = *(*[2]C.float)(unsafe.Pointer(&x.Pos)), cgoAllocsUnknown
	allocsa40e1546.Borrow(cpos_allocs)

	var ccolor_allocs *cgoAllocMap
	refa40e1546.color, ccolor_allocs = *(*[4]C.uchar)(unsafe.Pointer(&x.Color)), cgoAllocsUnknown
	allocsa40e1546.Borrow(ccolor_allocs)

	var ctex_allocs *cgoAllocMap
	refa40e1546.tex, ctex_allocs = *(*[2]C.float)(unsafe.Pointer(&x.Tex)), cgoAllocsUnknown
	allocsa40e1546.Borrow(ctex_allocs)

	var cobj_allocs *cgoAllocMap
	refa40e1546.obj, cobj_allocs = *(*[2]C.float)(unsafe.Pointer(&x.Obj)), cgoAllocsUnknown
	allocsa40e1546.Borrow(cobj_allocs)

	var cdata0_allocs *cgoAllocMap
	refa40e1546.data0, cdata0_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Data0)), cgoAllocsUnknown
	allocsa40e1546.Borrow(cdata0_allocs)

	var cdata1_allocs *cgoAllocMap
	refa40e1546.data1, cdata1_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Data1)), cgoAllocsUnknown
	allocsa40e1546.Borrow(cdata1_allocs)

	var cdata2_allocs *cgoAllocMap
	refa40e1546.data2, cdata2_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Data2)), cgoAllocsUnknown
	allocsa40e1546.Borrow(cdata2_allocs)

	var cdata3_allocs *cgoAllocMap
	refa40e1546.data3, cdata3_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Data3)), cgoAllocsUnknown
	allocsa40e1546.Borrow(cdata3_allocs)

	var cdata4_allocs *cgoAllocMap
	refa40e1546.data4, cdata4_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Data4)), cgoAllocsUnknown
	allocsa40e1546.Borrow(cdata4_allocs)

	var cdata5_allocs *cgoAllocMap
	refa40e1546.data5, cdata5_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Data5)), cgoAllocsUnknown
	allocsa40e1546.Borrow(cdata5_allocs)

	var cdata6_allocs *cgoAllocMap
	refa40e1546.data6, cdata6_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Data6)), cgoAllocsUnknown
	allocsa40e1546.Borrow(cdata6_allocs)

	x.refa40e1546 = refa40e1546
	x.allocsa40e1546 = allocsa40e1546
	return refa40e1546, allocsa40e1546

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULVertex2f4ub2f2f28f) PassValue() (C.ULVertex_2f_4ub_2f_2f_28f, *cgoAllocMap) {
	if x.refa40e1546 != nil {
		return *x.refa40e1546, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULVertex2f4ub2f2f28f) Deref() {
	if x.refa40e1546 == nil {
		return
	}
	x.Pos = *(*[2]float32)(unsafe.Pointer(&x.refa40e1546.pos))
	x.Color = *(*[4]byte)(unsafe.Pointer(&x.refa40e1546.color))
	x.Tex = *(*[2]float32)(unsafe.Pointer(&x.refa40e1546.tex))
	x.Obj = *(*[2]float32)(unsafe.Pointer(&x.refa40e1546.obj))
	x.Data0 = *(*[4]float32)(unsafe.Pointer(&x.refa40e1546.data0))
	x.Data1 = *(*[4]float32)(unsafe.Pointer(&x.refa40e1546.data1))
	x.Data2 = *(*[4]float32)(unsafe.Pointer(&x.refa40e1546.data2))
	x.Data3 = *(*[4]float32)(unsafe.Pointer(&x.refa40e1546.data3))
	x.Data4 = *(*[4]float32)(unsafe.Pointer(&x.refa40e1546.data4))
	x.Data5 = *(*[4]float32)(unsafe.Pointer(&x.refa40e1546.data5))
	x.Data6 = *(*[4]float32)(unsafe.Pointer(&x.refa40e1546.data6))
}

// allocULVertexBufferMemory allocates memory for type C.ULVertexBuffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULVertexBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULVertexBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULVertexBufferValue = unsafe.Sizeof([1]C.ULVertexBuffer{})

// copyPUcharBytes copies the data from Go slice as *C.uchar.
func copyPUcharBytes(slice *sliceHeader) (*C.uchar, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUcharValue) * slice.Len,
		Cap:  int(sizeOfUcharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uchar)(mem0), allocs
}

// allocUcharMemory allocates memory for type C.uchar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUcharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUcharValue = unsafe.Sizeof([1]C.uchar{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULVertexBuffer) Ref() *C.ULVertexBuffer {
	if x == nil {
		return nil
	}
	return x.ref38aa9279
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULVertexBuffer) Free() {
	if x != nil && x.allocs38aa9279 != nil {
		x.allocs38aa9279.(*cgoAllocMap).Free()
		x.ref38aa9279 = nil
	}
}

// NewULVertexBufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULVertexBufferRef(ref unsafe.Pointer) *ULVertexBuffer {
	if ref == nil {
		return nil
	}
	obj := new(ULVertexBuffer)
	obj.ref38aa9279 = (*C.ULVertexBuffer)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULVertexBuffer) PassRef() (*C.ULVertexBuffer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref38aa9279 != nil {
		return x.ref38aa9279, nil
	}
	mem38aa9279 := allocULVertexBufferMemory(1)
	ref38aa9279 := (*C.ULVertexBuffer)(mem38aa9279)
	allocs38aa9279 := new(cgoAllocMap)
	allocs38aa9279.Add(mem38aa9279)

	var cformat_allocs *cgoAllocMap
	ref38aa9279.format, cformat_allocs = (C.ULVertexBufferFormat)(x.Format), cgoAllocsUnknown
	allocs38aa9279.Borrow(cformat_allocs)

	var csize_allocs *cgoAllocMap
	ref38aa9279.size, csize_allocs = (C.uint)(x.Size), cgoAllocsUnknown
	allocs38aa9279.Borrow(csize_allocs)

	var cdata_allocs *cgoAllocMap
	ref38aa9279.data, cdata_allocs = copyPUcharBytes((*sliceHeader)(unsafe.Pointer(&x.Data)))
	allocs38aa9279.Borrow(cdata_allocs)

	x.ref38aa9279 = ref38aa9279
	x.allocs38aa9279 = allocs38aa9279
	return ref38aa9279, allocs38aa9279

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULVertexBuffer) PassValue() (C.ULVertexBuffer, *cgoAllocMap) {
	if x.ref38aa9279 != nil {
		return *x.ref38aa9279, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULVertexBuffer) Deref() {
	if x.ref38aa9279 == nil {
		return
	}
	x.Format = (ULVertexBufferFormat)(x.ref38aa9279.format)
	x.Size = (uint32)(x.ref38aa9279.size)
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.Data))
	hxff2234b.Data = unsafe.Pointer(x.ref38aa9279.data)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

}

// allocULIndexBufferMemory allocates memory for type C.ULIndexBuffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULIndexBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULIndexBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULIndexBufferValue = unsafe.Sizeof([1]C.ULIndexBuffer{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULIndexBuffer) Ref() *C.ULIndexBuffer {
	if x == nil {
		return nil
	}
	return x.ref8da49f64
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULIndexBuffer) Free() {
	if x != nil && x.allocs8da49f64 != nil {
		x.allocs8da49f64.(*cgoAllocMap).Free()
		x.ref8da49f64 = nil
	}
}

// NewULIndexBufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULIndexBufferRef(ref unsafe.Pointer) *ULIndexBuffer {
	if ref == nil {
		return nil
	}
	obj := new(ULIndexBuffer)
	obj.ref8da49f64 = (*C.ULIndexBuffer)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULIndexBuffer) PassRef() (*C.ULIndexBuffer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8da49f64 != nil {
		return x.ref8da49f64, nil
	}
	mem8da49f64 := allocULIndexBufferMemory(1)
	ref8da49f64 := (*C.ULIndexBuffer)(mem8da49f64)
	allocs8da49f64 := new(cgoAllocMap)
	allocs8da49f64.Add(mem8da49f64)

	var csize_allocs *cgoAllocMap
	ref8da49f64.size, csize_allocs = (C.uint)(x.Size), cgoAllocsUnknown
	allocs8da49f64.Borrow(csize_allocs)

	var cdata_allocs *cgoAllocMap
	ref8da49f64.data, cdata_allocs = copyPUcharBytes((*sliceHeader)(unsafe.Pointer(&x.Data)))
	allocs8da49f64.Borrow(cdata_allocs)

	x.ref8da49f64 = ref8da49f64
	x.allocs8da49f64 = allocs8da49f64
	return ref8da49f64, allocs8da49f64

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULIndexBuffer) PassValue() (C.ULIndexBuffer, *cgoAllocMap) {
	if x.ref8da49f64 != nil {
		return *x.ref8da49f64, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULIndexBuffer) Deref() {
	if x.ref8da49f64 == nil {
		return
	}
	x.Size = (uint32)(x.ref8da49f64.size)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.Data))
	hxff73280.Data = unsafe.Pointer(x.ref8da49f64.data)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

}

// allocULMatrix4x4Memory allocates memory for type C.ULMatrix4x4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULMatrix4x4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULMatrix4x4Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULMatrix4x4Value = unsafe.Sizeof([1]C.ULMatrix4x4{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULMatrix4x4) Ref() *C.ULMatrix4x4 {
	if x == nil {
		return nil
	}
	return x.ref5420ec6b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULMatrix4x4) Free() {
	if x != nil && x.allocs5420ec6b != nil {
		x.allocs5420ec6b.(*cgoAllocMap).Free()
		x.ref5420ec6b = nil
	}
}

// NewULMatrix4x4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULMatrix4x4Ref(ref unsafe.Pointer) *ULMatrix4x4 {
	if ref == nil {
		return nil
	}
	obj := new(ULMatrix4x4)
	obj.ref5420ec6b = (*C.ULMatrix4x4)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULMatrix4x4) PassRef() (*C.ULMatrix4x4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5420ec6b != nil {
		return x.ref5420ec6b, nil
	}
	mem5420ec6b := allocULMatrix4x4Memory(1)
	ref5420ec6b := (*C.ULMatrix4x4)(mem5420ec6b)
	allocs5420ec6b := new(cgoAllocMap)
	allocs5420ec6b.Add(mem5420ec6b)

	var cdata_allocs *cgoAllocMap
	ref5420ec6b.data, cdata_allocs = *(*[16]C.float)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs5420ec6b.Borrow(cdata_allocs)

	x.ref5420ec6b = ref5420ec6b
	x.allocs5420ec6b = allocs5420ec6b
	return ref5420ec6b, allocs5420ec6b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULMatrix4x4) PassValue() (C.ULMatrix4x4, *cgoAllocMap) {
	if x.ref5420ec6b != nil {
		return *x.ref5420ec6b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULMatrix4x4) Deref() {
	if x.ref5420ec6b == nil {
		return
	}
	x.Data = *(*[16]float32)(unsafe.Pointer(&x.ref5420ec6b.data))
}

// allocULvec4Memory allocates memory for type C.ULvec4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULvec4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULvec4Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULvec4Value = unsafe.Sizeof([1]C.ULvec4{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULvec4) Ref() *C.ULvec4 {
	if x == nil {
		return nil
	}
	return x.ref1faeb7f5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULvec4) Free() {
	if x != nil && x.allocs1faeb7f5 != nil {
		x.allocs1faeb7f5.(*cgoAllocMap).Free()
		x.ref1faeb7f5 = nil
	}
}

// NewULvec4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULvec4Ref(ref unsafe.Pointer) *ULvec4 {
	if ref == nil {
		return nil
	}
	obj := new(ULvec4)
	obj.ref1faeb7f5 = (*C.ULvec4)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULvec4) PassRef() (*C.ULvec4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1faeb7f5 != nil {
		return x.ref1faeb7f5, nil
	}
	mem1faeb7f5 := allocULvec4Memory(1)
	ref1faeb7f5 := (*C.ULvec4)(mem1faeb7f5)
	allocs1faeb7f5 := new(cgoAllocMap)
	allocs1faeb7f5.Add(mem1faeb7f5)

	var cvalue_allocs *cgoAllocMap
	ref1faeb7f5.value, cvalue_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Value)), cgoAllocsUnknown
	allocs1faeb7f5.Borrow(cvalue_allocs)

	x.ref1faeb7f5 = ref1faeb7f5
	x.allocs1faeb7f5 = allocs1faeb7f5
	return ref1faeb7f5, allocs1faeb7f5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULvec4) PassValue() (C.ULvec4, *cgoAllocMap) {
	if x.ref1faeb7f5 != nil {
		return *x.ref1faeb7f5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULvec4) Deref() {
	if x.ref1faeb7f5 == nil {
		return
	}
	x.Value = *(*[4]float32)(unsafe.Pointer(&x.ref1faeb7f5.value))
}

// allocULGPUStateMemory allocates memory for type C.ULGPUState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULGPUStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULGPUStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULGPUStateValue = unsafe.Sizeof([1]C.ULGPUState{})

// allocA8ULvec4Memory allocates memory for type [8]C.ULvec4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA8ULvec4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA8ULvec4Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA8ULvec4Value = unsafe.Sizeof([1][8]C.ULvec4{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackA8ULvec4 transforms a sliced Go data structure into plain C format.
func unpackA8ULvec4(x [8]ULvec4) (unpacked [8]C.ULvec4, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA8ULvec4Memory(1)
	allocs.Add(mem0)
	v0 := (*[8]C.ULvec4)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[8]C.ULvec4)(mem0)
	return
}

// allocA8ULMatrix4x4Memory allocates memory for type [8]C.ULMatrix4x4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA8ULMatrix4x4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA8ULMatrix4x4Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA8ULMatrix4x4Value = unsafe.Sizeof([1][8]C.ULMatrix4x4{})

// unpackA8ULMatrix4x4 transforms a sliced Go data structure into plain C format.
func unpackA8ULMatrix4x4(x [8]ULMatrix4x4) (unpacked [8]C.ULMatrix4x4, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA8ULMatrix4x4Memory(1)
	allocs.Add(mem0)
	v0 := (*[8]C.ULMatrix4x4)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[8]C.ULMatrix4x4)(mem0)
	return
}

// packA8ULvec4 reads sliced Go data structure out from plain C format.
func packA8ULvec4(v *[8]ULvec4, ptr0 *[8]C.ULvec4) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewULvec4Ref(unsafe.Pointer(&ptr1))
	}
}

// packA8ULMatrix4x4 reads sliced Go data structure out from plain C format.
func packA8ULMatrix4x4(v *[8]ULMatrix4x4, ptr0 *[8]C.ULMatrix4x4) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewULMatrix4x4Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULGPUState) Ref() *C.ULGPUState {
	if x == nil {
		return nil
	}
	return x.ref7caf648c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULGPUState) Free() {
	if x != nil && x.allocs7caf648c != nil {
		x.allocs7caf648c.(*cgoAllocMap).Free()
		x.ref7caf648c = nil
	}
}

// NewULGPUStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULGPUStateRef(ref unsafe.Pointer) *ULGPUState {
	if ref == nil {
		return nil
	}
	obj := new(ULGPUState)
	obj.ref7caf648c = (*C.ULGPUState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULGPUState) PassRef() (*C.ULGPUState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7caf648c != nil {
		return x.ref7caf648c, nil
	}
	mem7caf648c := allocULGPUStateMemory(1)
	ref7caf648c := (*C.ULGPUState)(mem7caf648c)
	allocs7caf648c := new(cgoAllocMap)
	allocs7caf648c.Add(mem7caf648c)

	var cviewport_width_allocs *cgoAllocMap
	ref7caf648c.viewport_width, cviewport_width_allocs = (C.uint)(x.ViewportWidth), cgoAllocsUnknown
	allocs7caf648c.Borrow(cviewport_width_allocs)

	var cviewport_height_allocs *cgoAllocMap
	ref7caf648c.viewport_height, cviewport_height_allocs = (C.uint)(x.ViewportHeight), cgoAllocsUnknown
	allocs7caf648c.Borrow(cviewport_height_allocs)

	var ctransform_allocs *cgoAllocMap
	ref7caf648c.transform, ctransform_allocs = x.Transform.PassValue()
	allocs7caf648c.Borrow(ctransform_allocs)

	var cenable_texturing_allocs *cgoAllocMap
	ref7caf648c.enable_texturing, cenable_texturing_allocs = (C._Bool)(x.EnableTexturing), cgoAllocsUnknown
	allocs7caf648c.Borrow(cenable_texturing_allocs)

	var cenable_blend_allocs *cgoAllocMap
	ref7caf648c.enable_blend, cenable_blend_allocs = (C._Bool)(x.EnableBlend), cgoAllocsUnknown
	allocs7caf648c.Borrow(cenable_blend_allocs)

	var cshader_type_allocs *cgoAllocMap
	ref7caf648c.shader_type, cshader_type_allocs = (C.uchar)(x.ShaderType), cgoAllocsUnknown
	allocs7caf648c.Borrow(cshader_type_allocs)

	var crender_buffer_id_allocs *cgoAllocMap
	ref7caf648c.render_buffer_id, crender_buffer_id_allocs = (C.uint)(x.RenderBufferId), cgoAllocsUnknown
	allocs7caf648c.Borrow(crender_buffer_id_allocs)

	var ctexture_1_id_allocs *cgoAllocMap
	ref7caf648c.texture_1_id, ctexture_1_id_allocs = (C.uint)(x.Texture1Id), cgoAllocsUnknown
	allocs7caf648c.Borrow(ctexture_1_id_allocs)

	var ctexture_2_id_allocs *cgoAllocMap
	ref7caf648c.texture_2_id, ctexture_2_id_allocs = (C.uint)(x.Texture2Id), cgoAllocsUnknown
	allocs7caf648c.Borrow(ctexture_2_id_allocs)

	var ctexture_3_id_allocs *cgoAllocMap
	ref7caf648c.texture_3_id, ctexture_3_id_allocs = (C.uint)(x.Texture3Id), cgoAllocsUnknown
	allocs7caf648c.Borrow(ctexture_3_id_allocs)

	var cuniform_scalar_allocs *cgoAllocMap
	ref7caf648c.uniform_scalar, cuniform_scalar_allocs = *(*[8]C.float)(unsafe.Pointer(&x.UniformScalar)), cgoAllocsUnknown
	allocs7caf648c.Borrow(cuniform_scalar_allocs)

	var cuniform_vector_allocs *cgoAllocMap
	ref7caf648c.uniform_vector, cuniform_vector_allocs = unpackA8ULvec4(x.UniformVector)
	allocs7caf648c.Borrow(cuniform_vector_allocs)

	var cclip_size_allocs *cgoAllocMap
	ref7caf648c.clip_size, cclip_size_allocs = (C.uchar)(x.ClipSize), cgoAllocsUnknown
	allocs7caf648c.Borrow(cclip_size_allocs)

	var cclip_allocs *cgoAllocMap
	ref7caf648c.clip, cclip_allocs = unpackA8ULMatrix4x4(x.Clip)
	allocs7caf648c.Borrow(cclip_allocs)

	var cenable_scissor_allocs *cgoAllocMap
	ref7caf648c.enable_scissor, cenable_scissor_allocs = (C._Bool)(x.EnableScissor), cgoAllocsUnknown
	allocs7caf648c.Borrow(cenable_scissor_allocs)

	var cscissor_rect_allocs *cgoAllocMap
	ref7caf648c.scissor_rect, cscissor_rect_allocs = x.ScissorRect.PassValue()
	allocs7caf648c.Borrow(cscissor_rect_allocs)

	x.ref7caf648c = ref7caf648c
	x.allocs7caf648c = allocs7caf648c
	return ref7caf648c, allocs7caf648c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULGPUState) PassValue() (C.ULGPUState, *cgoAllocMap) {
	if x.ref7caf648c != nil {
		return *x.ref7caf648c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULGPUState) Deref() {
	if x.ref7caf648c == nil {
		return
	}
	x.ViewportWidth = (uint32)(x.ref7caf648c.viewport_width)
	x.ViewportHeight = (uint32)(x.ref7caf648c.viewport_height)
	x.Transform = *NewULMatrix4x4Ref(unsafe.Pointer(&x.ref7caf648c.transform))
	x.EnableTexturing = (bool)(x.ref7caf648c.enable_texturing)
	x.EnableBlend = (bool)(x.ref7caf648c.enable_blend)
	x.ShaderType = (byte)(x.ref7caf648c.shader_type)
	x.RenderBufferId = (uint32)(x.ref7caf648c.render_buffer_id)
	x.Texture1Id = (uint32)(x.ref7caf648c.texture_1_id)
	x.Texture2Id = (uint32)(x.ref7caf648c.texture_2_id)
	x.Texture3Id = (uint32)(x.ref7caf648c.texture_3_id)
	x.UniformScalar = *(*[8]float32)(unsafe.Pointer(&x.ref7caf648c.uniform_scalar))
	packA8ULvec4(&x.UniformVector, (*[8]C.ULvec4)(unsafe.Pointer(&x.ref7caf648c.uniform_vector)))
	x.ClipSize = (byte)(x.ref7caf648c.clip_size)
	packA8ULMatrix4x4(&x.Clip, (*[8]C.ULMatrix4x4)(unsafe.Pointer(&x.ref7caf648c.clip)))
	x.EnableScissor = (bool)(x.ref7caf648c.enable_scissor)
	x.ScissorRect = *NewULIntRectRef(unsafe.Pointer(&x.ref7caf648c.scissor_rect))
}

// allocULCommandMemory allocates memory for type C.ULCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULCommandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULCommandValue = unsafe.Sizeof([1]C.ULCommand{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULCommand) Ref() *C.ULCommand {
	if x == nil {
		return nil
	}
	return x.ref7ce5cb03
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULCommand) Free() {
	if x != nil && x.allocs7ce5cb03 != nil {
		x.allocs7ce5cb03.(*cgoAllocMap).Free()
		x.ref7ce5cb03 = nil
	}
}

// NewULCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULCommandRef(ref unsafe.Pointer) *ULCommand {
	if ref == nil {
		return nil
	}
	obj := new(ULCommand)
	obj.ref7ce5cb03 = (*C.ULCommand)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULCommand) PassRef() (*C.ULCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ce5cb03 != nil {
		return x.ref7ce5cb03, nil
	}
	mem7ce5cb03 := allocULCommandMemory(1)
	ref7ce5cb03 := (*C.ULCommand)(mem7ce5cb03)
	allocs7ce5cb03 := new(cgoAllocMap)
	allocs7ce5cb03.Add(mem7ce5cb03)

	var ccommand_type_allocs *cgoAllocMap
	ref7ce5cb03.command_type, ccommand_type_allocs = (C.uchar)(x.CommandType), cgoAllocsUnknown
	allocs7ce5cb03.Borrow(ccommand_type_allocs)

	var cgpu_state_allocs *cgoAllocMap
	ref7ce5cb03.gpu_state, cgpu_state_allocs = x.GpuState.PassValue()
	allocs7ce5cb03.Borrow(cgpu_state_allocs)

	var cgeometry_id_allocs *cgoAllocMap
	ref7ce5cb03.geometry_id, cgeometry_id_allocs = (C.uint)(x.GeometryId), cgoAllocsUnknown
	allocs7ce5cb03.Borrow(cgeometry_id_allocs)

	var cindices_count_allocs *cgoAllocMap
	ref7ce5cb03.indices_count, cindices_count_allocs = (C.uint)(x.IndicesCount), cgoAllocsUnknown
	allocs7ce5cb03.Borrow(cindices_count_allocs)

	var cindices_offset_allocs *cgoAllocMap
	ref7ce5cb03.indices_offset, cindices_offset_allocs = (C.uint)(x.IndicesOffset), cgoAllocsUnknown
	allocs7ce5cb03.Borrow(cindices_offset_allocs)

	x.ref7ce5cb03 = ref7ce5cb03
	x.allocs7ce5cb03 = allocs7ce5cb03
	return ref7ce5cb03, allocs7ce5cb03

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULCommand) PassValue() (C.ULCommand, *cgoAllocMap) {
	if x.ref7ce5cb03 != nil {
		return *x.ref7ce5cb03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULCommand) Deref() {
	if x.ref7ce5cb03 == nil {
		return
	}
	x.CommandType = (byte)(x.ref7ce5cb03.command_type)
	x.GpuState = *NewULGPUStateRef(unsafe.Pointer(&x.ref7ce5cb03.gpu_state))
	x.GeometryId = (uint32)(x.ref7ce5cb03.geometry_id)
	x.IndicesCount = (uint32)(x.ref7ce5cb03.indices_count)
	x.IndicesOffset = (uint32)(x.ref7ce5cb03.indices_offset)
}

// allocULCommandListMemory allocates memory for type C.ULCommandList in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULCommandListMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULCommandListValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULCommandListValue = unsafe.Sizeof([1]C.ULCommandList{})

// unpackSULCommand transforms a sliced Go data structure into plain C format.
func unpackSULCommand(x []ULCommand) (unpacked *C.ULCommand, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocULCommandMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.ULCommand)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.ULCommand)(h.Data)
	return
}

// packSULCommand reads sliced Go data structure out from plain C format.
func packSULCommand(v []ULCommand, ptr0 *C.ULCommand) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfULCommandValue]C.ULCommand)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewULCommandRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULCommandList) Ref() *C.ULCommandList {
	if x == nil {
		return nil
	}
	return x.ref110fbbd7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULCommandList) Free() {
	if x != nil && x.allocs110fbbd7 != nil {
		x.allocs110fbbd7.(*cgoAllocMap).Free()
		x.ref110fbbd7 = nil
	}
}

// NewULCommandListRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULCommandListRef(ref unsafe.Pointer) *ULCommandList {
	if ref == nil {
		return nil
	}
	obj := new(ULCommandList)
	obj.ref110fbbd7 = (*C.ULCommandList)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULCommandList) PassRef() (*C.ULCommandList, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref110fbbd7 != nil {
		return x.ref110fbbd7, nil
	}
	mem110fbbd7 := allocULCommandListMemory(1)
	ref110fbbd7 := (*C.ULCommandList)(mem110fbbd7)
	allocs110fbbd7 := new(cgoAllocMap)
	allocs110fbbd7.Add(mem110fbbd7)

	var csize_allocs *cgoAllocMap
	ref110fbbd7.size, csize_allocs = (C.uint)(x.Size), cgoAllocsUnknown
	allocs110fbbd7.Borrow(csize_allocs)

	var ccommands_allocs *cgoAllocMap
	ref110fbbd7.commands, ccommands_allocs = unpackSULCommand(x.Commands)
	allocs110fbbd7.Borrow(ccommands_allocs)

	x.ref110fbbd7 = ref110fbbd7
	x.allocs110fbbd7 = allocs110fbbd7
	return ref110fbbd7, allocs110fbbd7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULCommandList) PassValue() (C.ULCommandList, *cgoAllocMap) {
	if x.ref110fbbd7 != nil {
		return *x.ref110fbbd7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULCommandList) Deref() {
	if x.ref110fbbd7 == nil {
		return
	}
	x.Size = (uint32)(x.ref110fbbd7.size)
	packSULCommand(x.Commands, x.ref110fbbd7.commands)
}

func (x ULGPUDriverBeginSynchronizeCallback) PassRef() (ref *C.ULGPUDriverBeginSynchronizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverBeginSynchronizeCallback650938CFunc == nil {
		uLGPUDriverBeginSynchronizeCallback650938CFunc = x
	}
	return (*C.ULGPUDriverBeginSynchronizeCallback)(C.ULGPUDriverBeginSynchronizeCallback_650938c), nil
}

func (x ULGPUDriverBeginSynchronizeCallback) PassValue() (ref C.ULGPUDriverBeginSynchronizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverBeginSynchronizeCallback650938CFunc == nil {
		uLGPUDriverBeginSynchronizeCallback650938CFunc = x
	}
	return (C.ULGPUDriverBeginSynchronizeCallback)(C.ULGPUDriverBeginSynchronizeCallback_650938c), nil
}

func NewULGPUDriverBeginSynchronizeCallbackRef(ref unsafe.Pointer) *ULGPUDriverBeginSynchronizeCallback {
	return (*ULGPUDriverBeginSynchronizeCallback)(ref)
}

//export uLGPUDriverBeginSynchronizeCallback650938C
func uLGPUDriverBeginSynchronizeCallback650938C() {
	if uLGPUDriverBeginSynchronizeCallback650938CFunc != nil {
		uLGPUDriverBeginSynchronizeCallback650938CFunc()
		return
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverBeginSynchronizeCallback650938CFunc ULGPUDriverBeginSynchronizeCallback

func (x ULGPUDriverEndSynchronizeCallback) PassRef() (ref *C.ULGPUDriverEndSynchronizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverEndSynchronizeCallbackF6BAAD4DFunc == nil {
		uLGPUDriverEndSynchronizeCallbackF6BAAD4DFunc = x
	}
	return (*C.ULGPUDriverEndSynchronizeCallback)(C.ULGPUDriverEndSynchronizeCallback_f6baad4d), nil
}

func (x ULGPUDriverEndSynchronizeCallback) PassValue() (ref C.ULGPUDriverEndSynchronizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverEndSynchronizeCallbackF6BAAD4DFunc == nil {
		uLGPUDriverEndSynchronizeCallbackF6BAAD4DFunc = x
	}
	return (C.ULGPUDriverEndSynchronizeCallback)(C.ULGPUDriverEndSynchronizeCallback_f6baad4d), nil
}

func NewULGPUDriverEndSynchronizeCallbackRef(ref unsafe.Pointer) *ULGPUDriverEndSynchronizeCallback {
	return (*ULGPUDriverEndSynchronizeCallback)(ref)
}

//export uLGPUDriverEndSynchronizeCallbackF6BAAD4D
func uLGPUDriverEndSynchronizeCallbackF6BAAD4D() {
	if uLGPUDriverEndSynchronizeCallbackF6BAAD4DFunc != nil {
		uLGPUDriverEndSynchronizeCallbackF6BAAD4DFunc()
		return
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverEndSynchronizeCallbackF6BAAD4DFunc ULGPUDriverEndSynchronizeCallback

func (x ULGPUDriverNextTextureIdCallback) PassRef() (ref *C.ULGPUDriverNextTextureIdCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverNextTextureIdCallback7DE045B4Func == nil {
		uLGPUDriverNextTextureIdCallback7DE045B4Func = x
	}
	return (*C.ULGPUDriverNextTextureIdCallback)(C.ULGPUDriverNextTextureIdCallback_7de045b4), nil
}

func (x ULGPUDriverNextTextureIdCallback) PassValue() (ref C.ULGPUDriverNextTextureIdCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverNextTextureIdCallback7DE045B4Func == nil {
		uLGPUDriverNextTextureIdCallback7DE045B4Func = x
	}
	return (C.ULGPUDriverNextTextureIdCallback)(C.ULGPUDriverNextTextureIdCallback_7de045b4), nil
}

func NewULGPUDriverNextTextureIdCallbackRef(ref unsafe.Pointer) *ULGPUDriverNextTextureIdCallback {
	return (*ULGPUDriverNextTextureIdCallback)(ref)
}

//export uLGPUDriverNextTextureIdCallback7DE045B4
func uLGPUDriverNextTextureIdCallback7DE045B4() C.uint {
	if uLGPUDriverNextTextureIdCallback7DE045B4Func != nil {
		ret7de045b4 := uLGPUDriverNextTextureIdCallback7DE045B4Func()
		ret, _ := (C.uint)(ret7de045b4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverNextTextureIdCallback7DE045B4Func ULGPUDriverNextTextureIdCallback

func (x ULGPUDriverCreateTextureCallback) PassRef() (ref *C.ULGPUDriverCreateTextureCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverCreateTextureCallbackA32244D8Func == nil {
		uLGPUDriverCreateTextureCallbackA32244D8Func = x
	}
	return (*C.ULGPUDriverCreateTextureCallback)(C.ULGPUDriverCreateTextureCallback_a32244d8), nil
}

func (x ULGPUDriverCreateTextureCallback) PassValue() (ref C.ULGPUDriverCreateTextureCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverCreateTextureCallbackA32244D8Func == nil {
		uLGPUDriverCreateTextureCallbackA32244D8Func = x
	}
	return (C.ULGPUDriverCreateTextureCallback)(C.ULGPUDriverCreateTextureCallback_a32244d8), nil
}

func NewULGPUDriverCreateTextureCallbackRef(ref unsafe.Pointer) *ULGPUDriverCreateTextureCallback {
	return (*ULGPUDriverCreateTextureCallback)(ref)
}

//export uLGPUDriverCreateTextureCallbackA32244D8
func uLGPUDriverCreateTextureCallbackA32244D8(ctextureId C.uint, cbitmap C.ULBitmap) {
	if uLGPUDriverCreateTextureCallbackA32244D8Func != nil {
		textureIda32244d8 := (uint32)(ctextureId)
		bitmapa32244d8 := *(*ULBitmap)(unsafe.Pointer(&cbitmap))
		uLGPUDriverCreateTextureCallbackA32244D8Func(textureIda32244d8, bitmapa32244d8)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverCreateTextureCallbackA32244D8Func ULGPUDriverCreateTextureCallback

func (x ULGPUDriverUpdateTextureCallback) PassRef() (ref *C.ULGPUDriverUpdateTextureCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverUpdateTextureCallback3D7A526Func == nil {
		uLGPUDriverUpdateTextureCallback3D7A526Func = x
	}
	return (*C.ULGPUDriverUpdateTextureCallback)(C.ULGPUDriverUpdateTextureCallback_3d7a526), nil
}

func (x ULGPUDriverUpdateTextureCallback) PassValue() (ref C.ULGPUDriverUpdateTextureCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverUpdateTextureCallback3D7A526Func == nil {
		uLGPUDriverUpdateTextureCallback3D7A526Func = x
	}
	return (C.ULGPUDriverUpdateTextureCallback)(C.ULGPUDriverUpdateTextureCallback_3d7a526), nil
}

func NewULGPUDriverUpdateTextureCallbackRef(ref unsafe.Pointer) *ULGPUDriverUpdateTextureCallback {
	return (*ULGPUDriverUpdateTextureCallback)(ref)
}

//export uLGPUDriverUpdateTextureCallback3D7A526
func uLGPUDriverUpdateTextureCallback3D7A526(ctextureId C.uint, cbitmap C.ULBitmap) {
	if uLGPUDriverUpdateTextureCallback3D7A526Func != nil {
		textureId3d7a526 := (uint32)(ctextureId)
		bitmap3d7a526 := *(*ULBitmap)(unsafe.Pointer(&cbitmap))
		uLGPUDriverUpdateTextureCallback3D7A526Func(textureId3d7a526, bitmap3d7a526)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverUpdateTextureCallback3D7A526Func ULGPUDriverUpdateTextureCallback

func (x ULGPUDriverDestroyTextureCallback) PassRef() (ref *C.ULGPUDriverDestroyTextureCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverDestroyTextureCallbackA8EEA310Func == nil {
		uLGPUDriverDestroyTextureCallbackA8EEA310Func = x
	}
	return (*C.ULGPUDriverDestroyTextureCallback)(C.ULGPUDriverDestroyTextureCallback_a8eea310), nil
}

func (x ULGPUDriverDestroyTextureCallback) PassValue() (ref C.ULGPUDriverDestroyTextureCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverDestroyTextureCallbackA8EEA310Func == nil {
		uLGPUDriverDestroyTextureCallbackA8EEA310Func = x
	}
	return (C.ULGPUDriverDestroyTextureCallback)(C.ULGPUDriverDestroyTextureCallback_a8eea310), nil
}

func NewULGPUDriverDestroyTextureCallbackRef(ref unsafe.Pointer) *ULGPUDriverDestroyTextureCallback {
	return (*ULGPUDriverDestroyTextureCallback)(ref)
}

//export uLGPUDriverDestroyTextureCallbackA8EEA310
func uLGPUDriverDestroyTextureCallbackA8EEA310(ctextureId C.uint) {
	if uLGPUDriverDestroyTextureCallbackA8EEA310Func != nil {
		textureIda8eea310 := (uint32)(ctextureId)
		uLGPUDriverDestroyTextureCallbackA8EEA310Func(textureIda8eea310)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverDestroyTextureCallbackA8EEA310Func ULGPUDriverDestroyTextureCallback

func (x ULGPUDriverNextRenderBufferIdCallback) PassRef() (ref *C.ULGPUDriverNextRenderBufferIdCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverNextRenderBufferIdCallbackBFEB3FB8Func == nil {
		uLGPUDriverNextRenderBufferIdCallbackBFEB3FB8Func = x
	}
	return (*C.ULGPUDriverNextRenderBufferIdCallback)(C.ULGPUDriverNextRenderBufferIdCallback_bfeb3fb8), nil
}

func (x ULGPUDriverNextRenderBufferIdCallback) PassValue() (ref C.ULGPUDriverNextRenderBufferIdCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverNextRenderBufferIdCallbackBFEB3FB8Func == nil {
		uLGPUDriverNextRenderBufferIdCallbackBFEB3FB8Func = x
	}
	return (C.ULGPUDriverNextRenderBufferIdCallback)(C.ULGPUDriverNextRenderBufferIdCallback_bfeb3fb8), nil
}

func NewULGPUDriverNextRenderBufferIdCallbackRef(ref unsafe.Pointer) *ULGPUDriverNextRenderBufferIdCallback {
	return (*ULGPUDriverNextRenderBufferIdCallback)(ref)
}

//export uLGPUDriverNextRenderBufferIdCallbackBFEB3FB8
func uLGPUDriverNextRenderBufferIdCallbackBFEB3FB8() C.uint {
	if uLGPUDriverNextRenderBufferIdCallbackBFEB3FB8Func != nil {
		retbfeb3fb8 := uLGPUDriverNextRenderBufferIdCallbackBFEB3FB8Func()
		ret, _ := (C.uint)(retbfeb3fb8), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverNextRenderBufferIdCallbackBFEB3FB8Func ULGPUDriverNextRenderBufferIdCallback

func (x ULGPUDriverCreateRenderBufferCallback) PassRef() (ref *C.ULGPUDriverCreateRenderBufferCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverCreateRenderBufferCallback68EE5367Func == nil {
		uLGPUDriverCreateRenderBufferCallback68EE5367Func = x
	}
	return (*C.ULGPUDriverCreateRenderBufferCallback)(C.ULGPUDriverCreateRenderBufferCallback_68ee5367), nil
}

func (x ULGPUDriverCreateRenderBufferCallback) PassValue() (ref C.ULGPUDriverCreateRenderBufferCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverCreateRenderBufferCallback68EE5367Func == nil {
		uLGPUDriverCreateRenderBufferCallback68EE5367Func = x
	}
	return (C.ULGPUDriverCreateRenderBufferCallback)(C.ULGPUDriverCreateRenderBufferCallback_68ee5367), nil
}

func NewULGPUDriverCreateRenderBufferCallbackRef(ref unsafe.Pointer) *ULGPUDriverCreateRenderBufferCallback {
	return (*ULGPUDriverCreateRenderBufferCallback)(ref)
}

//export uLGPUDriverCreateRenderBufferCallback68EE5367
func uLGPUDriverCreateRenderBufferCallback68EE5367(crenderBufferId C.uint, cbuffer C.ULRenderBuffer) {
	if uLGPUDriverCreateRenderBufferCallback68EE5367Func != nil {
		renderBufferId68ee5367 := (uint32)(crenderBufferId)
		buffer68ee5367 := *NewULRenderBufferRef(unsafe.Pointer(&cbuffer))
		uLGPUDriverCreateRenderBufferCallback68EE5367Func(renderBufferId68ee5367, buffer68ee5367)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverCreateRenderBufferCallback68EE5367Func ULGPUDriverCreateRenderBufferCallback

func (x ULGPUDriverDestroyRenderBufferCallback) PassRef() (ref *C.ULGPUDriverDestroyRenderBufferCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverDestroyRenderBufferCallback81623F13Func == nil {
		uLGPUDriverDestroyRenderBufferCallback81623F13Func = x
	}
	return (*C.ULGPUDriverDestroyRenderBufferCallback)(C.ULGPUDriverDestroyRenderBufferCallback_81623f13), nil
}

func (x ULGPUDriverDestroyRenderBufferCallback) PassValue() (ref C.ULGPUDriverDestroyRenderBufferCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverDestroyRenderBufferCallback81623F13Func == nil {
		uLGPUDriverDestroyRenderBufferCallback81623F13Func = x
	}
	return (C.ULGPUDriverDestroyRenderBufferCallback)(C.ULGPUDriverDestroyRenderBufferCallback_81623f13), nil
}

func NewULGPUDriverDestroyRenderBufferCallbackRef(ref unsafe.Pointer) *ULGPUDriverDestroyRenderBufferCallback {
	return (*ULGPUDriverDestroyRenderBufferCallback)(ref)
}

//export uLGPUDriverDestroyRenderBufferCallback81623F13
func uLGPUDriverDestroyRenderBufferCallback81623F13(crenderBufferId C.uint) {
	if uLGPUDriverDestroyRenderBufferCallback81623F13Func != nil {
		renderBufferId81623f13 := (uint32)(crenderBufferId)
		uLGPUDriverDestroyRenderBufferCallback81623F13Func(renderBufferId81623f13)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverDestroyRenderBufferCallback81623F13Func ULGPUDriverDestroyRenderBufferCallback

func (x ULGPUDriverNextGeometryIdCallback) PassRef() (ref *C.ULGPUDriverNextGeometryIdCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverNextGeometryIdCallback5F2A8FEAFunc == nil {
		uLGPUDriverNextGeometryIdCallback5F2A8FEAFunc = x
	}
	return (*C.ULGPUDriverNextGeometryIdCallback)(C.ULGPUDriverNextGeometryIdCallback_5f2a8fea), nil
}

func (x ULGPUDriverNextGeometryIdCallback) PassValue() (ref C.ULGPUDriverNextGeometryIdCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverNextGeometryIdCallback5F2A8FEAFunc == nil {
		uLGPUDriverNextGeometryIdCallback5F2A8FEAFunc = x
	}
	return (C.ULGPUDriverNextGeometryIdCallback)(C.ULGPUDriverNextGeometryIdCallback_5f2a8fea), nil
}

func NewULGPUDriverNextGeometryIdCallbackRef(ref unsafe.Pointer) *ULGPUDriverNextGeometryIdCallback {
	return (*ULGPUDriverNextGeometryIdCallback)(ref)
}

//export uLGPUDriverNextGeometryIdCallback5F2A8FEA
func uLGPUDriverNextGeometryIdCallback5F2A8FEA() C.uint {
	if uLGPUDriverNextGeometryIdCallback5F2A8FEAFunc != nil {
		ret5f2a8fea := uLGPUDriverNextGeometryIdCallback5F2A8FEAFunc()
		ret, _ := (C.uint)(ret5f2a8fea), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverNextGeometryIdCallback5F2A8FEAFunc ULGPUDriverNextGeometryIdCallback

func (x ULGPUDriverCreateGeometryCallback) PassRef() (ref *C.ULGPUDriverCreateGeometryCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverCreateGeometryCallback5957236DFunc == nil {
		uLGPUDriverCreateGeometryCallback5957236DFunc = x
	}
	return (*C.ULGPUDriverCreateGeometryCallback)(C.ULGPUDriverCreateGeometryCallback_5957236d), nil
}

func (x ULGPUDriverCreateGeometryCallback) PassValue() (ref C.ULGPUDriverCreateGeometryCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverCreateGeometryCallback5957236DFunc == nil {
		uLGPUDriverCreateGeometryCallback5957236DFunc = x
	}
	return (C.ULGPUDriverCreateGeometryCallback)(C.ULGPUDriverCreateGeometryCallback_5957236d), nil
}

func NewULGPUDriverCreateGeometryCallbackRef(ref unsafe.Pointer) *ULGPUDriverCreateGeometryCallback {
	return (*ULGPUDriverCreateGeometryCallback)(ref)
}

//export uLGPUDriverCreateGeometryCallback5957236D
func uLGPUDriverCreateGeometryCallback5957236D(cgeometryId C.uint, cvertices C.ULVertexBuffer, cindices C.ULIndexBuffer) {
	if uLGPUDriverCreateGeometryCallback5957236DFunc != nil {
		geometryId5957236d := (uint32)(cgeometryId)
		vertices5957236d := *NewULVertexBufferRef(unsafe.Pointer(&cvertices))
		indices5957236d := *NewULIndexBufferRef(unsafe.Pointer(&cindices))
		uLGPUDriverCreateGeometryCallback5957236DFunc(geometryId5957236d, vertices5957236d, indices5957236d)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverCreateGeometryCallback5957236DFunc ULGPUDriverCreateGeometryCallback

func (x ULGPUDriverUpdateGeometryCallback) PassRef() (ref *C.ULGPUDriverUpdateGeometryCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverUpdateGeometryCallback3F20997Func == nil {
		uLGPUDriverUpdateGeometryCallback3F20997Func = x
	}
	return (*C.ULGPUDriverUpdateGeometryCallback)(C.ULGPUDriverUpdateGeometryCallback_3f20997), nil
}

func (x ULGPUDriverUpdateGeometryCallback) PassValue() (ref C.ULGPUDriverUpdateGeometryCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverUpdateGeometryCallback3F20997Func == nil {
		uLGPUDriverUpdateGeometryCallback3F20997Func = x
	}
	return (C.ULGPUDriverUpdateGeometryCallback)(C.ULGPUDriverUpdateGeometryCallback_3f20997), nil
}

func NewULGPUDriverUpdateGeometryCallbackRef(ref unsafe.Pointer) *ULGPUDriverUpdateGeometryCallback {
	return (*ULGPUDriverUpdateGeometryCallback)(ref)
}

//export uLGPUDriverUpdateGeometryCallback3F20997
func uLGPUDriverUpdateGeometryCallback3F20997(cgeometryId C.uint, cvertices C.ULVertexBuffer, cindices C.ULIndexBuffer) {
	if uLGPUDriverUpdateGeometryCallback3F20997Func != nil {
		geometryId3f20997 := (uint32)(cgeometryId)
		vertices3f20997 := *NewULVertexBufferRef(unsafe.Pointer(&cvertices))
		indices3f20997 := *NewULIndexBufferRef(unsafe.Pointer(&cindices))
		uLGPUDriverUpdateGeometryCallback3F20997Func(geometryId3f20997, vertices3f20997, indices3f20997)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverUpdateGeometryCallback3F20997Func ULGPUDriverUpdateGeometryCallback

func (x ULGPUDriverDestroyGeometryCallback) PassRef() (ref *C.ULGPUDriverDestroyGeometryCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverDestroyGeometryCallbackCCE3A508Func == nil {
		uLGPUDriverDestroyGeometryCallbackCCE3A508Func = x
	}
	return (*C.ULGPUDriverDestroyGeometryCallback)(C.ULGPUDriverDestroyGeometryCallback_cce3a508), nil
}

func (x ULGPUDriverDestroyGeometryCallback) PassValue() (ref C.ULGPUDriverDestroyGeometryCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverDestroyGeometryCallbackCCE3A508Func == nil {
		uLGPUDriverDestroyGeometryCallbackCCE3A508Func = x
	}
	return (C.ULGPUDriverDestroyGeometryCallback)(C.ULGPUDriverDestroyGeometryCallback_cce3a508), nil
}

func NewULGPUDriverDestroyGeometryCallbackRef(ref unsafe.Pointer) *ULGPUDriverDestroyGeometryCallback {
	return (*ULGPUDriverDestroyGeometryCallback)(ref)
}

//export uLGPUDriverDestroyGeometryCallbackCCE3A508
func uLGPUDriverDestroyGeometryCallbackCCE3A508(cgeometryId C.uint) {
	if uLGPUDriverDestroyGeometryCallbackCCE3A508Func != nil {
		geometryIdcce3a508 := (uint32)(cgeometryId)
		uLGPUDriverDestroyGeometryCallbackCCE3A508Func(geometryIdcce3a508)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverDestroyGeometryCallbackCCE3A508Func ULGPUDriverDestroyGeometryCallback

func (x ULGPUDriverUpdateCommandListCallback) PassRef() (ref *C.ULGPUDriverUpdateCommandListCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverUpdateCommandListCallbackD3815A9EFunc == nil {
		uLGPUDriverUpdateCommandListCallbackD3815A9EFunc = x
	}
	return (*C.ULGPUDriverUpdateCommandListCallback)(C.ULGPUDriverUpdateCommandListCallback_d3815a9e), nil
}

func (x ULGPUDriverUpdateCommandListCallback) PassValue() (ref C.ULGPUDriverUpdateCommandListCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLGPUDriverUpdateCommandListCallbackD3815A9EFunc == nil {
		uLGPUDriverUpdateCommandListCallbackD3815A9EFunc = x
	}
	return (C.ULGPUDriverUpdateCommandListCallback)(C.ULGPUDriverUpdateCommandListCallback_d3815a9e), nil
}

func NewULGPUDriverUpdateCommandListCallbackRef(ref unsafe.Pointer) *ULGPUDriverUpdateCommandListCallback {
	return (*ULGPUDriverUpdateCommandListCallback)(ref)
}

//export uLGPUDriverUpdateCommandListCallbackD3815A9E
func uLGPUDriverUpdateCommandListCallbackD3815A9E(clist C.ULCommandList) {
	if uLGPUDriverUpdateCommandListCallbackD3815A9EFunc != nil {
		listd3815a9e := *NewULCommandListRef(unsafe.Pointer(&clist))
		uLGPUDriverUpdateCommandListCallbackD3815A9EFunc(listd3815a9e)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLGPUDriverUpdateCommandListCallbackD3815A9EFunc ULGPUDriverUpdateCommandListCallback

// allocULGPUDriverMemory allocates memory for type C.ULGPUDriver in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULGPUDriverMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULGPUDriverValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULGPUDriverValue = unsafe.Sizeof([1]C.ULGPUDriver{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULGPUDriver) Ref() *C.ULGPUDriver {
	if x == nil {
		return nil
	}
	return x.refdfd8a4f0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULGPUDriver) Free() {
	if x != nil && x.allocsdfd8a4f0 != nil {
		x.allocsdfd8a4f0.(*cgoAllocMap).Free()
		x.refdfd8a4f0 = nil
	}
}

// NewULGPUDriverRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULGPUDriverRef(ref unsafe.Pointer) *ULGPUDriver {
	if ref == nil {
		return nil
	}
	obj := new(ULGPUDriver)
	obj.refdfd8a4f0 = (*C.ULGPUDriver)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULGPUDriver) PassRef() (*C.ULGPUDriver, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdfd8a4f0 != nil {
		return x.refdfd8a4f0, nil
	}
	memdfd8a4f0 := allocULGPUDriverMemory(1)
	refdfd8a4f0 := (*C.ULGPUDriver)(memdfd8a4f0)
	allocsdfd8a4f0 := new(cgoAllocMap)
	allocsdfd8a4f0.Add(memdfd8a4f0)

	var cbegin_synchronize_allocs *cgoAllocMap
	refdfd8a4f0.begin_synchronize, cbegin_synchronize_allocs = x.BeginSynchronize.PassValue()
	allocsdfd8a4f0.Borrow(cbegin_synchronize_allocs)

	var cend_synchronize_allocs *cgoAllocMap
	refdfd8a4f0.end_synchronize, cend_synchronize_allocs = x.EndSynchronize.PassValue()
	allocsdfd8a4f0.Borrow(cend_synchronize_allocs)

	var cnext_texture_id_allocs *cgoAllocMap
	refdfd8a4f0.next_texture_id, cnext_texture_id_allocs = x.NextTextureId.PassValue()
	allocsdfd8a4f0.Borrow(cnext_texture_id_allocs)

	var ccreate_texture_allocs *cgoAllocMap
	refdfd8a4f0.create_texture, ccreate_texture_allocs = x.CreateTexture.PassValue()
	allocsdfd8a4f0.Borrow(ccreate_texture_allocs)

	var cupdate_texture_allocs *cgoAllocMap
	refdfd8a4f0.update_texture, cupdate_texture_allocs = x.UpdateTexture.PassValue()
	allocsdfd8a4f0.Borrow(cupdate_texture_allocs)

	var cdestroy_texture_allocs *cgoAllocMap
	refdfd8a4f0.destroy_texture, cdestroy_texture_allocs = x.DestroyTexture.PassValue()
	allocsdfd8a4f0.Borrow(cdestroy_texture_allocs)

	var cnext_render_buffer_id_allocs *cgoAllocMap
	refdfd8a4f0.next_render_buffer_id, cnext_render_buffer_id_allocs = x.NextRenderBufferId.PassValue()
	allocsdfd8a4f0.Borrow(cnext_render_buffer_id_allocs)

	var ccreate_render_buffer_allocs *cgoAllocMap
	refdfd8a4f0.create_render_buffer, ccreate_render_buffer_allocs = x.CreateRenderBuffer.PassValue()
	allocsdfd8a4f0.Borrow(ccreate_render_buffer_allocs)

	var cdestroy_render_buffer_allocs *cgoAllocMap
	refdfd8a4f0.destroy_render_buffer, cdestroy_render_buffer_allocs = x.DestroyRenderBuffer.PassValue()
	allocsdfd8a4f0.Borrow(cdestroy_render_buffer_allocs)

	var cnext_geometry_id_allocs *cgoAllocMap
	refdfd8a4f0.next_geometry_id, cnext_geometry_id_allocs = x.NextGeometryId.PassValue()
	allocsdfd8a4f0.Borrow(cnext_geometry_id_allocs)

	var ccreate_geometry_allocs *cgoAllocMap
	refdfd8a4f0.create_geometry, ccreate_geometry_allocs = x.CreateGeometry.PassValue()
	allocsdfd8a4f0.Borrow(ccreate_geometry_allocs)

	var cupdate_geometry_allocs *cgoAllocMap
	refdfd8a4f0.update_geometry, cupdate_geometry_allocs = x.UpdateGeometry.PassValue()
	allocsdfd8a4f0.Borrow(cupdate_geometry_allocs)

	var cdestroy_geometry_allocs *cgoAllocMap
	refdfd8a4f0.destroy_geometry, cdestroy_geometry_allocs = x.DestroyGeometry.PassValue()
	allocsdfd8a4f0.Borrow(cdestroy_geometry_allocs)

	var cupdate_command_list_allocs *cgoAllocMap
	refdfd8a4f0.update_command_list, cupdate_command_list_allocs = x.UpdateCommandList.PassValue()
	allocsdfd8a4f0.Borrow(cupdate_command_list_allocs)

	x.refdfd8a4f0 = refdfd8a4f0
	x.allocsdfd8a4f0 = allocsdfd8a4f0
	return refdfd8a4f0, allocsdfd8a4f0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULGPUDriver) PassValue() (C.ULGPUDriver, *cgoAllocMap) {
	if x.refdfd8a4f0 != nil {
		return *x.refdfd8a4f0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULGPUDriver) Deref() {
	if x.refdfd8a4f0 == nil {
		return
	}
	x.BeginSynchronize = *NewULGPUDriverBeginSynchronizeCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.begin_synchronize))
	x.EndSynchronize = *NewULGPUDriverEndSynchronizeCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.end_synchronize))
	x.NextTextureId = *NewULGPUDriverNextTextureIdCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.next_texture_id))
	x.CreateTexture = *NewULGPUDriverCreateTextureCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.create_texture))
	x.UpdateTexture = *NewULGPUDriverUpdateTextureCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.update_texture))
	x.DestroyTexture = *NewULGPUDriverDestroyTextureCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.destroy_texture))
	x.NextRenderBufferId = *NewULGPUDriverNextRenderBufferIdCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.next_render_buffer_id))
	x.CreateRenderBuffer = *NewULGPUDriverCreateRenderBufferCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.create_render_buffer))
	x.DestroyRenderBuffer = *NewULGPUDriverDestroyRenderBufferCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.destroy_render_buffer))
	x.NextGeometryId = *NewULGPUDriverNextGeometryIdCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.next_geometry_id))
	x.CreateGeometry = *NewULGPUDriverCreateGeometryCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.create_geometry))
	x.UpdateGeometry = *NewULGPUDriverUpdateGeometryCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.update_geometry))
	x.DestroyGeometry = *NewULGPUDriverDestroyGeometryCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.destroy_geometry))
	x.UpdateCommandList = *NewULGPUDriverUpdateCommandListCallbackRef(unsafe.Pointer(&x.refdfd8a4f0.update_command_list))
}

func (x ULClipboardClearCallback) PassRef() (ref *C.ULClipboardClearCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLClipboardClearCallbackEDA3036AFunc == nil {
		uLClipboardClearCallbackEDA3036AFunc = x
	}
	return (*C.ULClipboardClearCallback)(C.ULClipboardClearCallback_eda3036a), nil
}

func (x ULClipboardClearCallback) PassValue() (ref C.ULClipboardClearCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLClipboardClearCallbackEDA3036AFunc == nil {
		uLClipboardClearCallbackEDA3036AFunc = x
	}
	return (C.ULClipboardClearCallback)(C.ULClipboardClearCallback_eda3036a), nil
}

func NewULClipboardClearCallbackRef(ref unsafe.Pointer) *ULClipboardClearCallback {
	return (*ULClipboardClearCallback)(ref)
}

//export uLClipboardClearCallbackEDA3036A
func uLClipboardClearCallbackEDA3036A() {
	if uLClipboardClearCallbackEDA3036AFunc != nil {
		uLClipboardClearCallbackEDA3036AFunc()
		return
	}
	panic("callback func has not been set (race?)")
}

var uLClipboardClearCallbackEDA3036AFunc ULClipboardClearCallback

func (x ULClipboardReadPlainTextCallback) PassRef() (ref *C.ULClipboardReadPlainTextCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLClipboardReadPlainTextCallbackFEDFB2B6Func == nil {
		uLClipboardReadPlainTextCallbackFEDFB2B6Func = x
	}
	return (*C.ULClipboardReadPlainTextCallback)(C.ULClipboardReadPlainTextCallback_fedfb2b6), nil
}

func (x ULClipboardReadPlainTextCallback) PassValue() (ref C.ULClipboardReadPlainTextCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLClipboardReadPlainTextCallbackFEDFB2B6Func == nil {
		uLClipboardReadPlainTextCallbackFEDFB2B6Func = x
	}
	return (C.ULClipboardReadPlainTextCallback)(C.ULClipboardReadPlainTextCallback_fedfb2b6), nil
}

func NewULClipboardReadPlainTextCallbackRef(ref unsafe.Pointer) *ULClipboardReadPlainTextCallback {
	return (*ULClipboardReadPlainTextCallback)(ref)
}

//export uLClipboardReadPlainTextCallbackFEDFB2B6
func uLClipboardReadPlainTextCallbackFEDFB2B6(cresult C.ULString) {
	if uLClipboardReadPlainTextCallbackFEDFB2B6Func != nil {
		resultfedfb2b6 := *(*ULString)(unsafe.Pointer(&cresult))
		uLClipboardReadPlainTextCallbackFEDFB2B6Func(resultfedfb2b6)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLClipboardReadPlainTextCallbackFEDFB2B6Func ULClipboardReadPlainTextCallback

func (x ULClipboardWritePlainTextCallback) PassRef() (ref *C.ULClipboardWritePlainTextCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLClipboardWritePlainTextCallback6E8E0CA4Func == nil {
		uLClipboardWritePlainTextCallback6E8E0CA4Func = x
	}
	return (*C.ULClipboardWritePlainTextCallback)(C.ULClipboardWritePlainTextCallback_6e8e0ca4), nil
}

func (x ULClipboardWritePlainTextCallback) PassValue() (ref C.ULClipboardWritePlainTextCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLClipboardWritePlainTextCallback6E8E0CA4Func == nil {
		uLClipboardWritePlainTextCallback6E8E0CA4Func = x
	}
	return (C.ULClipboardWritePlainTextCallback)(C.ULClipboardWritePlainTextCallback_6e8e0ca4), nil
}

func NewULClipboardWritePlainTextCallbackRef(ref unsafe.Pointer) *ULClipboardWritePlainTextCallback {
	return (*ULClipboardWritePlainTextCallback)(ref)
}

//export uLClipboardWritePlainTextCallback6E8E0CA4
func uLClipboardWritePlainTextCallback6E8E0CA4(ctext C.ULString) {
	if uLClipboardWritePlainTextCallback6E8E0CA4Func != nil {
		text6e8e0ca4 := *(*ULString)(unsafe.Pointer(&ctext))
		uLClipboardWritePlainTextCallback6E8E0CA4Func(text6e8e0ca4)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLClipboardWritePlainTextCallback6E8E0CA4Func ULClipboardWritePlainTextCallback

// allocULClipboardMemory allocates memory for type C.ULClipboard in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULClipboardMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULClipboardValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULClipboardValue = unsafe.Sizeof([1]C.ULClipboard{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ULClipboard) Ref() *C.ULClipboard {
	if x == nil {
		return nil
	}
	return x.refdcb753f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ULClipboard) Free() {
	if x != nil && x.allocsdcb753f != nil {
		x.allocsdcb753f.(*cgoAllocMap).Free()
		x.refdcb753f = nil
	}
}

// NewULClipboardRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewULClipboardRef(ref unsafe.Pointer) *ULClipboard {
	if ref == nil {
		return nil
	}
	obj := new(ULClipboard)
	obj.refdcb753f = (*C.ULClipboard)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ULClipboard) PassRef() (*C.ULClipboard, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdcb753f != nil {
		return x.refdcb753f, nil
	}
	memdcb753f := allocULClipboardMemory(1)
	refdcb753f := (*C.ULClipboard)(memdcb753f)
	allocsdcb753f := new(cgoAllocMap)
	allocsdcb753f.Add(memdcb753f)

	var cclear_allocs *cgoAllocMap
	refdcb753f.clear, cclear_allocs = x.Clear.PassValue()
	allocsdcb753f.Borrow(cclear_allocs)

	var cread_plain_text_allocs *cgoAllocMap
	refdcb753f.read_plain_text, cread_plain_text_allocs = x.ReadPlainText.PassValue()
	allocsdcb753f.Borrow(cread_plain_text_allocs)

	var cwrite_plain_text_allocs *cgoAllocMap
	refdcb753f.write_plain_text, cwrite_plain_text_allocs = x.WritePlainText.PassValue()
	allocsdcb753f.Borrow(cwrite_plain_text_allocs)

	x.refdcb753f = refdcb753f
	x.allocsdcb753f = allocsdcb753f
	return refdcb753f, allocsdcb753f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ULClipboard) PassValue() (C.ULClipboard, *cgoAllocMap) {
	if x.refdcb753f != nil {
		return *x.refdcb753f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ULClipboard) Deref() {
	if x.refdcb753f == nil {
		return
	}
	x.Clear = *NewULClipboardClearCallbackRef(unsafe.Pointer(&x.refdcb753f.clear))
	x.ReadPlainText = *NewULClipboardReadPlainTextCallbackRef(unsafe.Pointer(&x.refdcb753f.read_plain_text))
	x.WritePlainText = *NewULClipboardWritePlainTextCallbackRef(unsafe.Pointer(&x.refdcb753f.write_plain_text))
}

func (x JSTypedArrayBytesDeallocator) PassRef() (ref *C.JSTypedArrayBytesDeallocator, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSTypedArrayBytesDeallocator68D51F83Func == nil {
		jSTypedArrayBytesDeallocator68D51F83Func = x
	}
	return (*C.JSTypedArrayBytesDeallocator)(C.JSTypedArrayBytesDeallocator_68d51f83), nil
}

func (x JSTypedArrayBytesDeallocator) PassValue() (ref C.JSTypedArrayBytesDeallocator, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSTypedArrayBytesDeallocator68D51F83Func == nil {
		jSTypedArrayBytesDeallocator68D51F83Func = x
	}
	return (C.JSTypedArrayBytesDeallocator)(C.JSTypedArrayBytesDeallocator_68d51f83), nil
}

func NewJSTypedArrayBytesDeallocatorRef(ref unsafe.Pointer) *JSTypedArrayBytesDeallocator {
	return (*JSTypedArrayBytesDeallocator)(ref)
}

//export jSTypedArrayBytesDeallocator68D51F83
func jSTypedArrayBytesDeallocator68D51F83(cbytes unsafe.Pointer, cdeallocatorContext unsafe.Pointer) {
	if jSTypedArrayBytesDeallocator68D51F83Func != nil {
		bytes68d51f83 := (unsafe.Pointer)(unsafe.Pointer(cbytes))
		deallocatorContext68d51f83 := (unsafe.Pointer)(unsafe.Pointer(cdeallocatorContext))
		jSTypedArrayBytesDeallocator68D51F83Func(bytes68d51f83, deallocatorContext68d51f83)
		return
	}
	panic("callback func has not been set (race?)")
}

var jSTypedArrayBytesDeallocator68D51F83Func JSTypedArrayBytesDeallocator

func (x JSObjectInitializeCallback) PassRef() (ref *C.JSObjectInitializeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectInitializeCallback5793B16Func == nil {
		jSObjectInitializeCallback5793B16Func = x
	}
	return (*C.JSObjectInitializeCallback)(C.JSObjectInitializeCallback_5793b16), nil
}

func (x JSObjectInitializeCallback) PassValue() (ref C.JSObjectInitializeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectInitializeCallback5793B16Func == nil {
		jSObjectInitializeCallback5793B16Func = x
	}
	return (C.JSObjectInitializeCallback)(C.JSObjectInitializeCallback_5793b16), nil
}

func NewJSObjectInitializeCallbackRef(ref unsafe.Pointer) *JSObjectInitializeCallback {
	return (*JSObjectInitializeCallback)(ref)
}

//export jSObjectInitializeCallback5793B16
func jSObjectInitializeCallback5793B16(cctx C.JSContextRef, cobject C.JSObjectRef) {
	if jSObjectInitializeCallback5793B16Func != nil {
		ctx5793b16 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		object5793b16 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		jSObjectInitializeCallback5793B16Func(ctx5793b16, object5793b16)
		return
	}
	panic("callback func has not been set (race?)")
}

var jSObjectInitializeCallback5793B16Func JSObjectInitializeCallback

func (x JSObjectInitializeCallbackEx) PassRef() (ref *C.JSObjectInitializeCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectInitializeCallbackEx3F9A093BFunc == nil {
		jSObjectInitializeCallbackEx3F9A093BFunc = x
	}
	return (*C.JSObjectInitializeCallbackEx)(C.JSObjectInitializeCallbackEx_3f9a093b), nil
}

func (x JSObjectInitializeCallbackEx) PassValue() (ref C.JSObjectInitializeCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectInitializeCallbackEx3F9A093BFunc == nil {
		jSObjectInitializeCallbackEx3F9A093BFunc = x
	}
	return (C.JSObjectInitializeCallbackEx)(C.JSObjectInitializeCallbackEx_3f9a093b), nil
}

func NewJSObjectInitializeCallbackExRef(ref unsafe.Pointer) *JSObjectInitializeCallbackEx {
	return (*JSObjectInitializeCallbackEx)(ref)
}

//export jSObjectInitializeCallbackEx3F9A093B
func jSObjectInitializeCallbackEx3F9A093B(cctx C.JSContextRef, cjsClass C.JSClassRef, cobject C.JSObjectRef) {
	if jSObjectInitializeCallbackEx3F9A093BFunc != nil {
		ctx3f9a093b := *(*JSContextRef)(unsafe.Pointer(&cctx))
		jsClass3f9a093b := *(*JSClassRef)(unsafe.Pointer(&cjsClass))
		object3f9a093b := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		jSObjectInitializeCallbackEx3F9A093BFunc(ctx3f9a093b, jsClass3f9a093b, object3f9a093b)
		return
	}
	panic("callback func has not been set (race?)")
}

var jSObjectInitializeCallbackEx3F9A093BFunc JSObjectInitializeCallbackEx

func (x JSObjectFinalizeCallback) PassRef() (ref *C.JSObjectFinalizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectFinalizeCallback93DA0AEAFunc == nil {
		jSObjectFinalizeCallback93DA0AEAFunc = x
	}
	return (*C.JSObjectFinalizeCallback)(C.JSObjectFinalizeCallback_93da0aea), nil
}

func (x JSObjectFinalizeCallback) PassValue() (ref C.JSObjectFinalizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectFinalizeCallback93DA0AEAFunc == nil {
		jSObjectFinalizeCallback93DA0AEAFunc = x
	}
	return (C.JSObjectFinalizeCallback)(C.JSObjectFinalizeCallback_93da0aea), nil
}

func NewJSObjectFinalizeCallbackRef(ref unsafe.Pointer) *JSObjectFinalizeCallback {
	return (*JSObjectFinalizeCallback)(ref)
}

//export jSObjectFinalizeCallback93DA0AEA
func jSObjectFinalizeCallback93DA0AEA(cobject C.JSObjectRef) {
	if jSObjectFinalizeCallback93DA0AEAFunc != nil {
		object93da0aea := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		jSObjectFinalizeCallback93DA0AEAFunc(object93da0aea)
		return
	}
	panic("callback func has not been set (race?)")
}

var jSObjectFinalizeCallback93DA0AEAFunc JSObjectFinalizeCallback

func (x JSObjectFinalizeCallbackEx) PassRef() (ref *C.JSObjectFinalizeCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectFinalizeCallbackExD64D3113Func == nil {
		jSObjectFinalizeCallbackExD64D3113Func = x
	}
	return (*C.JSObjectFinalizeCallbackEx)(C.JSObjectFinalizeCallbackEx_d64d3113), nil
}

func (x JSObjectFinalizeCallbackEx) PassValue() (ref C.JSObjectFinalizeCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectFinalizeCallbackExD64D3113Func == nil {
		jSObjectFinalizeCallbackExD64D3113Func = x
	}
	return (C.JSObjectFinalizeCallbackEx)(C.JSObjectFinalizeCallbackEx_d64d3113), nil
}

func NewJSObjectFinalizeCallbackExRef(ref unsafe.Pointer) *JSObjectFinalizeCallbackEx {
	return (*JSObjectFinalizeCallbackEx)(ref)
}

//export jSObjectFinalizeCallbackExD64D3113
func jSObjectFinalizeCallbackExD64D3113(cjsClass C.JSClassRef, cobject C.JSObjectRef) {
	if jSObjectFinalizeCallbackExD64D3113Func != nil {
		jsClassd64d3113 := *(*JSClassRef)(unsafe.Pointer(&cjsClass))
		objectd64d3113 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		jSObjectFinalizeCallbackExD64D3113Func(jsClassd64d3113, objectd64d3113)
		return
	}
	panic("callback func has not been set (race?)")
}

var jSObjectFinalizeCallbackExD64D3113Func JSObjectFinalizeCallbackEx

func (x JSObjectHasPropertyCallback) PassRef() (ref *C.JSObjectHasPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasPropertyCallback340BFA95Func == nil {
		jSObjectHasPropertyCallback340BFA95Func = x
	}
	return (*C.JSObjectHasPropertyCallback)(C.JSObjectHasPropertyCallback_340bfa95), nil
}

func (x JSObjectHasPropertyCallback) PassValue() (ref C.JSObjectHasPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasPropertyCallback340BFA95Func == nil {
		jSObjectHasPropertyCallback340BFA95Func = x
	}
	return (C.JSObjectHasPropertyCallback)(C.JSObjectHasPropertyCallback_340bfa95), nil
}

func NewJSObjectHasPropertyCallbackRef(ref unsafe.Pointer) *JSObjectHasPropertyCallback {
	return (*JSObjectHasPropertyCallback)(ref)
}

//export jSObjectHasPropertyCallback340BFA95
func jSObjectHasPropertyCallback340BFA95(cctx C.JSContextRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef) C._Bool {
	if jSObjectHasPropertyCallback340BFA95Func != nil {
		ctx340bfa95 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		object340bfa95 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyName340bfa95 := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		ret340bfa95 := jSObjectHasPropertyCallback340BFA95Func(ctx340bfa95, object340bfa95, propertyName340bfa95)
		ret, _ := (C._Bool)(ret340bfa95), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectHasPropertyCallback340BFA95Func JSObjectHasPropertyCallback

func (x JSObjectHasPropertyCallbackEx) PassRef() (ref *C.JSObjectHasPropertyCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasPropertyCallbackExC35701E7Func == nil {
		jSObjectHasPropertyCallbackExC35701E7Func = x
	}
	return (*C.JSObjectHasPropertyCallbackEx)(C.JSObjectHasPropertyCallbackEx_c35701e7), nil
}

func (x JSObjectHasPropertyCallbackEx) PassValue() (ref C.JSObjectHasPropertyCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasPropertyCallbackExC35701E7Func == nil {
		jSObjectHasPropertyCallbackExC35701E7Func = x
	}
	return (C.JSObjectHasPropertyCallbackEx)(C.JSObjectHasPropertyCallbackEx_c35701e7), nil
}

func NewJSObjectHasPropertyCallbackExRef(ref unsafe.Pointer) *JSObjectHasPropertyCallbackEx {
	return (*JSObjectHasPropertyCallbackEx)(ref)
}

//export jSObjectHasPropertyCallbackExC35701E7
func jSObjectHasPropertyCallbackExC35701E7(cctx C.JSContextRef, cjsClass C.JSClassRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef) C._Bool {
	if jSObjectHasPropertyCallbackExC35701E7Func != nil {
		ctxc35701e7 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		jsClassc35701e7 := *(*JSClassRef)(unsafe.Pointer(&cjsClass))
		objectc35701e7 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyNamec35701e7 := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		retc35701e7 := jSObjectHasPropertyCallbackExC35701E7Func(ctxc35701e7, jsClassc35701e7, objectc35701e7, propertyNamec35701e7)
		ret, _ := (C._Bool)(retc35701e7), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectHasPropertyCallbackExC35701E7Func JSObjectHasPropertyCallbackEx

func (x JSObjectGetPropertyCallback) PassRef() (ref *C.JSObjectGetPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyCallback5CAEC716Func == nil {
		jSObjectGetPropertyCallback5CAEC716Func = x
	}
	return (*C.JSObjectGetPropertyCallback)(C.JSObjectGetPropertyCallback_5caec716), nil
}

func (x JSObjectGetPropertyCallback) PassValue() (ref C.JSObjectGetPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyCallback5CAEC716Func == nil {
		jSObjectGetPropertyCallback5CAEC716Func = x
	}
	return (C.JSObjectGetPropertyCallback)(C.JSObjectGetPropertyCallback_5caec716), nil
}

func NewJSObjectGetPropertyCallbackRef(ref unsafe.Pointer) *JSObjectGetPropertyCallback {
	return (*JSObjectGetPropertyCallback)(ref)
}

//export jSObjectGetPropertyCallback5CAEC716
func jSObjectGetPropertyCallback5CAEC716(cctx C.JSContextRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef, cexception *C.JSValueRef) C.JSValueRef {
	if jSObjectGetPropertyCallback5CAEC716Func != nil {
		ctx5caec716 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		object5caec716 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyName5caec716 := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		var exception5caec716 []JSValueRef
		hxfa9955c := (*sliceHeader)(unsafe.Pointer(&exception5caec716))
		hxfa9955c.Data = unsafe.Pointer(cexception)
		hxfa9955c.Cap = 0x7fffffff
		// hxfa9955c.Len = ?

		ret5caec716 := jSObjectGetPropertyCallback5CAEC716Func(ctx5caec716, object5caec716, propertyName5caec716, exception5caec716)
		ret, _ := *(*C.JSValueRef)(unsafe.Pointer(&ret5caec716)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectGetPropertyCallback5CAEC716Func JSObjectGetPropertyCallback

func (x JSObjectGetPropertyCallbackEx) PassRef() (ref *C.JSObjectGetPropertyCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyCallbackEx8B91EEDBFunc == nil {
		jSObjectGetPropertyCallbackEx8B91EEDBFunc = x
	}
	return (*C.JSObjectGetPropertyCallbackEx)(C.JSObjectGetPropertyCallbackEx_8b91eedb), nil
}

func (x JSObjectGetPropertyCallbackEx) PassValue() (ref C.JSObjectGetPropertyCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyCallbackEx8B91EEDBFunc == nil {
		jSObjectGetPropertyCallbackEx8B91EEDBFunc = x
	}
	return (C.JSObjectGetPropertyCallbackEx)(C.JSObjectGetPropertyCallbackEx_8b91eedb), nil
}

func NewJSObjectGetPropertyCallbackExRef(ref unsafe.Pointer) *JSObjectGetPropertyCallbackEx {
	return (*JSObjectGetPropertyCallbackEx)(ref)
}

//export jSObjectGetPropertyCallbackEx8B91EEDB
func jSObjectGetPropertyCallbackEx8B91EEDB(cctx C.JSContextRef, cjsClass C.JSClassRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef, cexception *C.JSValueRef) C.JSValueRef {
	if jSObjectGetPropertyCallbackEx8B91EEDBFunc != nil {
		ctx8b91eedb := *(*JSContextRef)(unsafe.Pointer(&cctx))
		jsClass8b91eedb := *(*JSClassRef)(unsafe.Pointer(&cjsClass))
		object8b91eedb := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyName8b91eedb := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		var exception8b91eedb []JSValueRef
		hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&exception8b91eedb))
		hxfa3f05c.Data = unsafe.Pointer(cexception)
		hxfa3f05c.Cap = 0x7fffffff
		// hxfa3f05c.Len = ?

		ret8b91eedb := jSObjectGetPropertyCallbackEx8B91EEDBFunc(ctx8b91eedb, jsClass8b91eedb, object8b91eedb, propertyName8b91eedb, exception8b91eedb)
		ret, _ := *(*C.JSValueRef)(unsafe.Pointer(&ret8b91eedb)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectGetPropertyCallbackEx8B91EEDBFunc JSObjectGetPropertyCallbackEx

func (x JSObjectSetPropertyCallback) PassRef() (ref *C.JSObjectSetPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectSetPropertyCallbackA684F1FEFunc == nil {
		jSObjectSetPropertyCallbackA684F1FEFunc = x
	}
	return (*C.JSObjectSetPropertyCallback)(C.JSObjectSetPropertyCallback_a684f1fe), nil
}

func (x JSObjectSetPropertyCallback) PassValue() (ref C.JSObjectSetPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectSetPropertyCallbackA684F1FEFunc == nil {
		jSObjectSetPropertyCallbackA684F1FEFunc = x
	}
	return (C.JSObjectSetPropertyCallback)(C.JSObjectSetPropertyCallback_a684f1fe), nil
}

func NewJSObjectSetPropertyCallbackRef(ref unsafe.Pointer) *JSObjectSetPropertyCallback {
	return (*JSObjectSetPropertyCallback)(ref)
}

//export jSObjectSetPropertyCallbackA684F1FE
func jSObjectSetPropertyCallbackA684F1FE(cctx C.JSContextRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef, cvalue C.JSValueRef, cexception *C.JSValueRef) C._Bool {
	if jSObjectSetPropertyCallbackA684F1FEFunc != nil {
		ctxa684f1fe := *(*JSContextRef)(unsafe.Pointer(&cctx))
		objecta684f1fe := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyNamea684f1fe := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		valuea684f1fe := *(*JSValueRef)(unsafe.Pointer(&cvalue))
		var exceptiona684f1fe []JSValueRef
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&exceptiona684f1fe))
		hxf0d18b7.Data = unsafe.Pointer(cexception)
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?

		reta684f1fe := jSObjectSetPropertyCallbackA684F1FEFunc(ctxa684f1fe, objecta684f1fe, propertyNamea684f1fe, valuea684f1fe, exceptiona684f1fe)
		ret, _ := (C._Bool)(reta684f1fe), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectSetPropertyCallbackA684F1FEFunc JSObjectSetPropertyCallback

func (x JSObjectSetPropertyCallbackEx) PassRef() (ref *C.JSObjectSetPropertyCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectSetPropertyCallbackExD28CF88CFunc == nil {
		jSObjectSetPropertyCallbackExD28CF88CFunc = x
	}
	return (*C.JSObjectSetPropertyCallbackEx)(C.JSObjectSetPropertyCallbackEx_d28cf88c), nil
}

func (x JSObjectSetPropertyCallbackEx) PassValue() (ref C.JSObjectSetPropertyCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectSetPropertyCallbackExD28CF88CFunc == nil {
		jSObjectSetPropertyCallbackExD28CF88CFunc = x
	}
	return (C.JSObjectSetPropertyCallbackEx)(C.JSObjectSetPropertyCallbackEx_d28cf88c), nil
}

func NewJSObjectSetPropertyCallbackExRef(ref unsafe.Pointer) *JSObjectSetPropertyCallbackEx {
	return (*JSObjectSetPropertyCallbackEx)(ref)
}

//export jSObjectSetPropertyCallbackExD28CF88C
func jSObjectSetPropertyCallbackExD28CF88C(cctx C.JSContextRef, cjsClass C.JSClassRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef, cvalue C.JSValueRef, cexception *C.JSValueRef) C._Bool {
	if jSObjectSetPropertyCallbackExD28CF88CFunc != nil {
		ctxd28cf88c := *(*JSContextRef)(unsafe.Pointer(&cctx))
		jsClassd28cf88c := *(*JSClassRef)(unsafe.Pointer(&cjsClass))
		objectd28cf88c := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyNamed28cf88c := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		valued28cf88c := *(*JSValueRef)(unsafe.Pointer(&cvalue))
		var exceptiond28cf88c []JSValueRef
		hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&exceptiond28cf88c))
		hxf2fab0d.Data = unsafe.Pointer(cexception)
		hxf2fab0d.Cap = 0x7fffffff
		// hxf2fab0d.Len = ?

		retd28cf88c := jSObjectSetPropertyCallbackExD28CF88CFunc(ctxd28cf88c, jsClassd28cf88c, objectd28cf88c, propertyNamed28cf88c, valued28cf88c, exceptiond28cf88c)
		ret, _ := (C._Bool)(retd28cf88c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectSetPropertyCallbackExD28CF88CFunc JSObjectSetPropertyCallbackEx

func (x JSObjectDeletePropertyCallback) PassRef() (ref *C.JSObjectDeletePropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectDeletePropertyCallbackB0108EBEFunc == nil {
		jSObjectDeletePropertyCallbackB0108EBEFunc = x
	}
	return (*C.JSObjectDeletePropertyCallback)(C.JSObjectDeletePropertyCallback_b0108ebe), nil
}

func (x JSObjectDeletePropertyCallback) PassValue() (ref C.JSObjectDeletePropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectDeletePropertyCallbackB0108EBEFunc == nil {
		jSObjectDeletePropertyCallbackB0108EBEFunc = x
	}
	return (C.JSObjectDeletePropertyCallback)(C.JSObjectDeletePropertyCallback_b0108ebe), nil
}

func NewJSObjectDeletePropertyCallbackRef(ref unsafe.Pointer) *JSObjectDeletePropertyCallback {
	return (*JSObjectDeletePropertyCallback)(ref)
}

//export jSObjectDeletePropertyCallbackB0108EBE
func jSObjectDeletePropertyCallbackB0108EBE(cctx C.JSContextRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef, cexception *C.JSValueRef) C._Bool {
	if jSObjectDeletePropertyCallbackB0108EBEFunc != nil {
		ctxb0108ebe := *(*JSContextRef)(unsafe.Pointer(&cctx))
		objectb0108ebe := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyNameb0108ebe := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		var exceptionb0108ebe []JSValueRef
		hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&exceptionb0108ebe))
		hxf69fe70.Data = unsafe.Pointer(cexception)
		hxf69fe70.Cap = 0x7fffffff
		// hxf69fe70.Len = ?

		retb0108ebe := jSObjectDeletePropertyCallbackB0108EBEFunc(ctxb0108ebe, objectb0108ebe, propertyNameb0108ebe, exceptionb0108ebe)
		ret, _ := (C._Bool)(retb0108ebe), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectDeletePropertyCallbackB0108EBEFunc JSObjectDeletePropertyCallback

func (x JSObjectDeletePropertyCallbackEx) PassRef() (ref *C.JSObjectDeletePropertyCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectDeletePropertyCallbackExE24FCDB0Func == nil {
		jSObjectDeletePropertyCallbackExE24FCDB0Func = x
	}
	return (*C.JSObjectDeletePropertyCallbackEx)(C.JSObjectDeletePropertyCallbackEx_e24fcdb0), nil
}

func (x JSObjectDeletePropertyCallbackEx) PassValue() (ref C.JSObjectDeletePropertyCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectDeletePropertyCallbackExE24FCDB0Func == nil {
		jSObjectDeletePropertyCallbackExE24FCDB0Func = x
	}
	return (C.JSObjectDeletePropertyCallbackEx)(C.JSObjectDeletePropertyCallbackEx_e24fcdb0), nil
}

func NewJSObjectDeletePropertyCallbackExRef(ref unsafe.Pointer) *JSObjectDeletePropertyCallbackEx {
	return (*JSObjectDeletePropertyCallbackEx)(ref)
}

//export jSObjectDeletePropertyCallbackExE24FCDB0
func jSObjectDeletePropertyCallbackExE24FCDB0(cctx C.JSContextRef, cjsClass C.JSClassRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef, cexception *C.JSValueRef) C._Bool {
	if jSObjectDeletePropertyCallbackExE24FCDB0Func != nil {
		ctxe24fcdb0 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		jsClasse24fcdb0 := *(*JSClassRef)(unsafe.Pointer(&cjsClass))
		objecte24fcdb0 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyNamee24fcdb0 := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		var exceptione24fcdb0 []JSValueRef
		hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&exceptione24fcdb0))
		hxf65bf54.Data = unsafe.Pointer(cexception)
		hxf65bf54.Cap = 0x7fffffff
		// hxf65bf54.Len = ?

		rete24fcdb0 := jSObjectDeletePropertyCallbackExE24FCDB0Func(ctxe24fcdb0, jsClasse24fcdb0, objecte24fcdb0, propertyNamee24fcdb0, exceptione24fcdb0)
		ret, _ := (C._Bool)(rete24fcdb0), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectDeletePropertyCallbackExE24FCDB0Func JSObjectDeletePropertyCallbackEx

func (x JSObjectGetPropertyNamesCallback) PassRef() (ref *C.JSObjectGetPropertyNamesCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyNamesCallbackE77D2329Func == nil {
		jSObjectGetPropertyNamesCallbackE77D2329Func = x
	}
	return (*C.JSObjectGetPropertyNamesCallback)(C.JSObjectGetPropertyNamesCallback_e77d2329), nil
}

func (x JSObjectGetPropertyNamesCallback) PassValue() (ref C.JSObjectGetPropertyNamesCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyNamesCallbackE77D2329Func == nil {
		jSObjectGetPropertyNamesCallbackE77D2329Func = x
	}
	return (C.JSObjectGetPropertyNamesCallback)(C.JSObjectGetPropertyNamesCallback_e77d2329), nil
}

func NewJSObjectGetPropertyNamesCallbackRef(ref unsafe.Pointer) *JSObjectGetPropertyNamesCallback {
	return (*JSObjectGetPropertyNamesCallback)(ref)
}

//export jSObjectGetPropertyNamesCallbackE77D2329
func jSObjectGetPropertyNamesCallbackE77D2329(cctx C.JSContextRef, cobject C.JSObjectRef, cpropertyNames C.JSPropertyNameAccumulatorRef) {
	if jSObjectGetPropertyNamesCallbackE77D2329Func != nil {
		ctxe77d2329 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		objecte77d2329 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyNamese77d2329 := *(*JSPropertyNameAccumulatorRef)(unsafe.Pointer(&cpropertyNames))
		jSObjectGetPropertyNamesCallbackE77D2329Func(ctxe77d2329, objecte77d2329, propertyNamese77d2329)
		return
	}
	panic("callback func has not been set (race?)")
}

var jSObjectGetPropertyNamesCallbackE77D2329Func JSObjectGetPropertyNamesCallback

func (x JSObjectGetPropertyNamesCallbackEx) PassRef() (ref *C.JSObjectGetPropertyNamesCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyNamesCallbackEx74285955Func == nil {
		jSObjectGetPropertyNamesCallbackEx74285955Func = x
	}
	return (*C.JSObjectGetPropertyNamesCallbackEx)(C.JSObjectGetPropertyNamesCallbackEx_74285955), nil
}

func (x JSObjectGetPropertyNamesCallbackEx) PassValue() (ref C.JSObjectGetPropertyNamesCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyNamesCallbackEx74285955Func == nil {
		jSObjectGetPropertyNamesCallbackEx74285955Func = x
	}
	return (C.JSObjectGetPropertyNamesCallbackEx)(C.JSObjectGetPropertyNamesCallbackEx_74285955), nil
}

func NewJSObjectGetPropertyNamesCallbackExRef(ref unsafe.Pointer) *JSObjectGetPropertyNamesCallbackEx {
	return (*JSObjectGetPropertyNamesCallbackEx)(ref)
}

//export jSObjectGetPropertyNamesCallbackEx74285955
func jSObjectGetPropertyNamesCallbackEx74285955(cctx C.JSContextRef, cjsClass C.JSClassRef, cobject C.JSObjectRef, cpropertyNames C.JSPropertyNameAccumulatorRef) {
	if jSObjectGetPropertyNamesCallbackEx74285955Func != nil {
		ctx74285955 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		jsClass74285955 := *(*JSClassRef)(unsafe.Pointer(&cjsClass))
		object74285955 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyNames74285955 := *(*JSPropertyNameAccumulatorRef)(unsafe.Pointer(&cpropertyNames))
		jSObjectGetPropertyNamesCallbackEx74285955Func(ctx74285955, jsClass74285955, object74285955, propertyNames74285955)
		return
	}
	panic("callback func has not been set (race?)")
}

var jSObjectGetPropertyNamesCallbackEx74285955Func JSObjectGetPropertyNamesCallbackEx

func (x JSObjectCallAsFunctionCallback) PassRef() (ref *C.JSObjectCallAsFunctionCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsFunctionCallback89F9469BFunc == nil {
		jSObjectCallAsFunctionCallback89F9469BFunc = x
	}
	return (*C.JSObjectCallAsFunctionCallback)(C.JSObjectCallAsFunctionCallback_89f9469b), nil
}

func (x JSObjectCallAsFunctionCallback) PassValue() (ref C.JSObjectCallAsFunctionCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsFunctionCallback89F9469BFunc == nil {
		jSObjectCallAsFunctionCallback89F9469BFunc = x
	}
	return (C.JSObjectCallAsFunctionCallback)(C.JSObjectCallAsFunctionCallback_89f9469b), nil
}

func NewJSObjectCallAsFunctionCallbackRef(ref unsafe.Pointer) *JSObjectCallAsFunctionCallback {
	return (*JSObjectCallAsFunctionCallback)(ref)
}

//export jSObjectCallAsFunctionCallback89F9469B
func jSObjectCallAsFunctionCallback89F9469B(cctx C.JSContextRef, cfunction C.JSObjectRef, cthisObject C.JSObjectRef, cargumentCount C.size_t, carguments *C.JSValueRef, cexception *C.JSValueRef) C.JSValueRef {
	if jSObjectCallAsFunctionCallback89F9469BFunc != nil {
		ctx89f9469b := *(*JSContextRef)(unsafe.Pointer(&cctx))
		function89f9469b := *(*JSObjectRef)(unsafe.Pointer(&cfunction))
		thisObject89f9469b := *(*JSObjectRef)(unsafe.Pointer(&cthisObject))
		argumentCount89f9469b := (uint32)(cargumentCount)
		var arguments89f9469b []JSValueRef
		hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&arguments89f9469b))
		hxf3b8dbd.Data = unsafe.Pointer(carguments)
		hxf3b8dbd.Cap = 0x7fffffff
		// hxf3b8dbd.Len = ?

		var exception89f9469b []JSValueRef
		hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&exception89f9469b))
		hxf7a6dff.Data = unsafe.Pointer(cexception)
		hxf7a6dff.Cap = 0x7fffffff
		// hxf7a6dff.Len = ?

		ret89f9469b := jSObjectCallAsFunctionCallback89F9469BFunc(ctx89f9469b, function89f9469b, thisObject89f9469b, argumentCount89f9469b, arguments89f9469b, exception89f9469b)
		ret, _ := *(*C.JSValueRef)(unsafe.Pointer(&ret89f9469b)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectCallAsFunctionCallback89F9469BFunc JSObjectCallAsFunctionCallback

func (x JSObjectCallAsFunctionCallbackEx) PassRef() (ref *C.JSObjectCallAsFunctionCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsFunctionCallbackEx9F036E3CFunc == nil {
		jSObjectCallAsFunctionCallbackEx9F036E3CFunc = x
	}
	return (*C.JSObjectCallAsFunctionCallbackEx)(C.JSObjectCallAsFunctionCallbackEx_9f036e3c), nil
}

func (x JSObjectCallAsFunctionCallbackEx) PassValue() (ref C.JSObjectCallAsFunctionCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsFunctionCallbackEx9F036E3CFunc == nil {
		jSObjectCallAsFunctionCallbackEx9F036E3CFunc = x
	}
	return (C.JSObjectCallAsFunctionCallbackEx)(C.JSObjectCallAsFunctionCallbackEx_9f036e3c), nil
}

func NewJSObjectCallAsFunctionCallbackExRef(ref unsafe.Pointer) *JSObjectCallAsFunctionCallbackEx {
	return (*JSObjectCallAsFunctionCallbackEx)(ref)
}

//export jSObjectCallAsFunctionCallbackEx9F036E3C
func jSObjectCallAsFunctionCallbackEx9F036E3C(cctx C.JSContextRef, cjsClass C.JSClassRef, cclassName C.JSStringRef, cfunction C.JSObjectRef, cthisObject C.JSObjectRef, cargumentCount C.size_t, carguments *C.JSValueRef, cexception *C.JSValueRef) C.JSValueRef {
	if jSObjectCallAsFunctionCallbackEx9F036E3CFunc != nil {
		ctx9f036e3c := *(*JSContextRef)(unsafe.Pointer(&cctx))
		jsClass9f036e3c := *(*JSClassRef)(unsafe.Pointer(&cjsClass))
		className9f036e3c := *(*JSStringRef)(unsafe.Pointer(&cclassName))
		function9f036e3c := *(*JSObjectRef)(unsafe.Pointer(&cfunction))
		thisObject9f036e3c := *(*JSObjectRef)(unsafe.Pointer(&cthisObject))
		argumentCount9f036e3c := (uint32)(cargumentCount)
		var arguments9f036e3c []JSValueRef
		hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&arguments9f036e3c))
		hxfe48d67.Data = unsafe.Pointer(carguments)
		hxfe48d67.Cap = 0x7fffffff
		// hxfe48d67.Len = ?

		var exception9f036e3c []JSValueRef
		hxf4171bf := (*sliceHeader)(unsafe.Pointer(&exception9f036e3c))
		hxf4171bf.Data = unsafe.Pointer(cexception)
		hxf4171bf.Cap = 0x7fffffff
		// hxf4171bf.Len = ?

		ret9f036e3c := jSObjectCallAsFunctionCallbackEx9F036E3CFunc(ctx9f036e3c, jsClass9f036e3c, className9f036e3c, function9f036e3c, thisObject9f036e3c, argumentCount9f036e3c, arguments9f036e3c, exception9f036e3c)
		ret, _ := *(*C.JSValueRef)(unsafe.Pointer(&ret9f036e3c)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectCallAsFunctionCallbackEx9F036E3CFunc JSObjectCallAsFunctionCallbackEx

func (x JSObjectCallAsConstructorCallback) PassRef() (ref *C.JSObjectCallAsConstructorCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsConstructorCallback45F4B71FFunc == nil {
		jSObjectCallAsConstructorCallback45F4B71FFunc = x
	}
	return (*C.JSObjectCallAsConstructorCallback)(C.JSObjectCallAsConstructorCallback_45f4b71f), nil
}

func (x JSObjectCallAsConstructorCallback) PassValue() (ref C.JSObjectCallAsConstructorCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsConstructorCallback45F4B71FFunc == nil {
		jSObjectCallAsConstructorCallback45F4B71FFunc = x
	}
	return (C.JSObjectCallAsConstructorCallback)(C.JSObjectCallAsConstructorCallback_45f4b71f), nil
}

func NewJSObjectCallAsConstructorCallbackRef(ref unsafe.Pointer) *JSObjectCallAsConstructorCallback {
	return (*JSObjectCallAsConstructorCallback)(ref)
}

//export jSObjectCallAsConstructorCallback45F4B71F
func jSObjectCallAsConstructorCallback45F4B71F(cctx C.JSContextRef, cconstructor C.JSObjectRef, cargumentCount C.size_t, carguments *C.JSValueRef, cexception *C.JSValueRef) C.JSObjectRef {
	if jSObjectCallAsConstructorCallback45F4B71FFunc != nil {
		ctx45f4b71f := *(*JSContextRef)(unsafe.Pointer(&cctx))
		constructor45f4b71f := *(*JSObjectRef)(unsafe.Pointer(&cconstructor))
		argumentCount45f4b71f := (uint32)(cargumentCount)
		var arguments45f4b71f []JSValueRef
		hxf058b18 := (*sliceHeader)(unsafe.Pointer(&arguments45f4b71f))
		hxf058b18.Data = unsafe.Pointer(carguments)
		hxf058b18.Cap = 0x7fffffff
		// hxf058b18.Len = ?

		var exception45f4b71f []JSValueRef
		hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&exception45f4b71f))
		hxff6bc57.Data = unsafe.Pointer(cexception)
		hxff6bc57.Cap = 0x7fffffff
		// hxff6bc57.Len = ?

		ret45f4b71f := jSObjectCallAsConstructorCallback45F4B71FFunc(ctx45f4b71f, constructor45f4b71f, argumentCount45f4b71f, arguments45f4b71f, exception45f4b71f)
		ret, _ := *(*C.JSObjectRef)(unsafe.Pointer(&ret45f4b71f)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectCallAsConstructorCallback45F4B71FFunc JSObjectCallAsConstructorCallback

func (x JSObjectCallAsConstructorCallbackEx) PassRef() (ref *C.JSObjectCallAsConstructorCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsConstructorCallbackExA563DF4Func == nil {
		jSObjectCallAsConstructorCallbackExA563DF4Func = x
	}
	return (*C.JSObjectCallAsConstructorCallbackEx)(C.JSObjectCallAsConstructorCallbackEx_a563df4), nil
}

func (x JSObjectCallAsConstructorCallbackEx) PassValue() (ref C.JSObjectCallAsConstructorCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsConstructorCallbackExA563DF4Func == nil {
		jSObjectCallAsConstructorCallbackExA563DF4Func = x
	}
	return (C.JSObjectCallAsConstructorCallbackEx)(C.JSObjectCallAsConstructorCallbackEx_a563df4), nil
}

func NewJSObjectCallAsConstructorCallbackExRef(ref unsafe.Pointer) *JSObjectCallAsConstructorCallbackEx {
	return (*JSObjectCallAsConstructorCallbackEx)(ref)
}

//export jSObjectCallAsConstructorCallbackExA563DF4
func jSObjectCallAsConstructorCallbackExA563DF4(cctx C.JSContextRef, cjsClass C.JSClassRef, cconstructor C.JSObjectRef, cargumentCount C.size_t, carguments *C.JSValueRef, cexception *C.JSValueRef) C.JSObjectRef {
	if jSObjectCallAsConstructorCallbackExA563DF4Func != nil {
		ctxa563df4 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		jsClassa563df4 := *(*JSClassRef)(unsafe.Pointer(&cjsClass))
		constructora563df4 := *(*JSObjectRef)(unsafe.Pointer(&cconstructor))
		argumentCounta563df4 := (uint32)(cargumentCount)
		var argumentsa563df4 []JSValueRef
		hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&argumentsa563df4))
		hxf5fa529.Data = unsafe.Pointer(carguments)
		hxf5fa529.Cap = 0x7fffffff
		// hxf5fa529.Len = ?

		var exceptiona563df4 []JSValueRef
		hxf21690b := (*sliceHeader)(unsafe.Pointer(&exceptiona563df4))
		hxf21690b.Data = unsafe.Pointer(cexception)
		hxf21690b.Cap = 0x7fffffff
		// hxf21690b.Len = ?

		reta563df4 := jSObjectCallAsConstructorCallbackExA563DF4Func(ctxa563df4, jsClassa563df4, constructora563df4, argumentCounta563df4, argumentsa563df4, exceptiona563df4)
		ret, _ := *(*C.JSObjectRef)(unsafe.Pointer(&reta563df4)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectCallAsConstructorCallbackExA563DF4Func JSObjectCallAsConstructorCallbackEx

func (x JSObjectHasInstanceCallback) PassRef() (ref *C.JSObjectHasInstanceCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasInstanceCallbackAA527D2EFunc == nil {
		jSObjectHasInstanceCallbackAA527D2EFunc = x
	}
	return (*C.JSObjectHasInstanceCallback)(C.JSObjectHasInstanceCallback_aa527d2e), nil
}

func (x JSObjectHasInstanceCallback) PassValue() (ref C.JSObjectHasInstanceCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasInstanceCallbackAA527D2EFunc == nil {
		jSObjectHasInstanceCallbackAA527D2EFunc = x
	}
	return (C.JSObjectHasInstanceCallback)(C.JSObjectHasInstanceCallback_aa527d2e), nil
}

func NewJSObjectHasInstanceCallbackRef(ref unsafe.Pointer) *JSObjectHasInstanceCallback {
	return (*JSObjectHasInstanceCallback)(ref)
}

//export jSObjectHasInstanceCallbackAA527D2E
func jSObjectHasInstanceCallbackAA527D2E(cctx C.JSContextRef, cconstructor C.JSObjectRef, cpossibleInstance C.JSValueRef, cexception *C.JSValueRef) C._Bool {
	if jSObjectHasInstanceCallbackAA527D2EFunc != nil {
		ctxaa527d2e := *(*JSContextRef)(unsafe.Pointer(&cctx))
		constructoraa527d2e := *(*JSObjectRef)(unsafe.Pointer(&cconstructor))
		possibleInstanceaa527d2e := *(*JSValueRef)(unsafe.Pointer(&cpossibleInstance))
		var exceptionaa527d2e []JSValueRef
		hxf1231c9 := (*sliceHeader)(unsafe.Pointer(&exceptionaa527d2e))
		hxf1231c9.Data = unsafe.Pointer(cexception)
		hxf1231c9.Cap = 0x7fffffff
		// hxf1231c9.Len = ?

		retaa527d2e := jSObjectHasInstanceCallbackAA527D2EFunc(ctxaa527d2e, constructoraa527d2e, possibleInstanceaa527d2e, exceptionaa527d2e)
		ret, _ := (C._Bool)(retaa527d2e), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectHasInstanceCallbackAA527D2EFunc JSObjectHasInstanceCallback

func (x JSObjectHasInstanceCallbackEx) PassRef() (ref *C.JSObjectHasInstanceCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasInstanceCallbackExB7BAFE4EFunc == nil {
		jSObjectHasInstanceCallbackExB7BAFE4EFunc = x
	}
	return (*C.JSObjectHasInstanceCallbackEx)(C.JSObjectHasInstanceCallbackEx_b7bafe4e), nil
}

func (x JSObjectHasInstanceCallbackEx) PassValue() (ref C.JSObjectHasInstanceCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasInstanceCallbackExB7BAFE4EFunc == nil {
		jSObjectHasInstanceCallbackExB7BAFE4EFunc = x
	}
	return (C.JSObjectHasInstanceCallbackEx)(C.JSObjectHasInstanceCallbackEx_b7bafe4e), nil
}

func NewJSObjectHasInstanceCallbackExRef(ref unsafe.Pointer) *JSObjectHasInstanceCallbackEx {
	return (*JSObjectHasInstanceCallbackEx)(ref)
}

//export jSObjectHasInstanceCallbackExB7BAFE4E
func jSObjectHasInstanceCallbackExB7BAFE4E(cctx C.JSContextRef, cjsClass C.JSClassRef, cconstructor C.JSObjectRef, cpossibleInstance C.JSValueRef, cexception *C.JSValueRef) C._Bool {
	if jSObjectHasInstanceCallbackExB7BAFE4EFunc != nil {
		ctxb7bafe4e := *(*JSContextRef)(unsafe.Pointer(&cctx))
		jsClassb7bafe4e := *(*JSClassRef)(unsafe.Pointer(&cjsClass))
		constructorb7bafe4e := *(*JSObjectRef)(unsafe.Pointer(&cconstructor))
		possibleInstanceb7bafe4e := *(*JSValueRef)(unsafe.Pointer(&cpossibleInstance))
		var exceptionb7bafe4e []JSValueRef
		hxf04b15b := (*sliceHeader)(unsafe.Pointer(&exceptionb7bafe4e))
		hxf04b15b.Data = unsafe.Pointer(cexception)
		hxf04b15b.Cap = 0x7fffffff
		// hxf04b15b.Len = ?

		retb7bafe4e := jSObjectHasInstanceCallbackExB7BAFE4EFunc(ctxb7bafe4e, jsClassb7bafe4e, constructorb7bafe4e, possibleInstanceb7bafe4e, exceptionb7bafe4e)
		ret, _ := (C._Bool)(retb7bafe4e), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectHasInstanceCallbackExB7BAFE4EFunc JSObjectHasInstanceCallbackEx

func (x JSObjectConvertToTypeCallback) PassRef() (ref *C.JSObjectConvertToTypeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectConvertToTypeCallbackD379D61CFunc == nil {
		jSObjectConvertToTypeCallbackD379D61CFunc = x
	}
	return (*C.JSObjectConvertToTypeCallback)(C.JSObjectConvertToTypeCallback_d379d61c), nil
}

func (x JSObjectConvertToTypeCallback) PassValue() (ref C.JSObjectConvertToTypeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectConvertToTypeCallbackD379D61CFunc == nil {
		jSObjectConvertToTypeCallbackD379D61CFunc = x
	}
	return (C.JSObjectConvertToTypeCallback)(C.JSObjectConvertToTypeCallback_d379d61c), nil
}

func NewJSObjectConvertToTypeCallbackRef(ref unsafe.Pointer) *JSObjectConvertToTypeCallback {
	return (*JSObjectConvertToTypeCallback)(ref)
}

//export jSObjectConvertToTypeCallbackD379D61C
func jSObjectConvertToTypeCallbackD379D61C(cctx C.JSContextRef, cobject C.JSObjectRef, ckind C.JSType, cexception *C.JSValueRef) C.JSValueRef {
	if jSObjectConvertToTypeCallbackD379D61CFunc != nil {
		ctxd379d61c := *(*JSContextRef)(unsafe.Pointer(&cctx))
		objectd379d61c := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		kindd379d61c := (JSType)(ckind)
		var exceptiond379d61c []JSValueRef
		hxf2f888b := (*sliceHeader)(unsafe.Pointer(&exceptiond379d61c))
		hxf2f888b.Data = unsafe.Pointer(cexception)
		hxf2f888b.Cap = 0x7fffffff
		// hxf2f888b.Len = ?

		retd379d61c := jSObjectConvertToTypeCallbackD379D61CFunc(ctxd379d61c, objectd379d61c, kindd379d61c, exceptiond379d61c)
		ret, _ := *(*C.JSValueRef)(unsafe.Pointer(&retd379d61c)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectConvertToTypeCallbackD379D61CFunc JSObjectConvertToTypeCallback

func (x JSObjectConvertToTypeCallbackEx) PassRef() (ref *C.JSObjectConvertToTypeCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectConvertToTypeCallbackEx1BCEA974Func == nil {
		jSObjectConvertToTypeCallbackEx1BCEA974Func = x
	}
	return (*C.JSObjectConvertToTypeCallbackEx)(C.JSObjectConvertToTypeCallbackEx_1bcea974), nil
}

func (x JSObjectConvertToTypeCallbackEx) PassValue() (ref C.JSObjectConvertToTypeCallbackEx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectConvertToTypeCallbackEx1BCEA974Func == nil {
		jSObjectConvertToTypeCallbackEx1BCEA974Func = x
	}
	return (C.JSObjectConvertToTypeCallbackEx)(C.JSObjectConvertToTypeCallbackEx_1bcea974), nil
}

func NewJSObjectConvertToTypeCallbackExRef(ref unsafe.Pointer) *JSObjectConvertToTypeCallbackEx {
	return (*JSObjectConvertToTypeCallbackEx)(ref)
}

//export jSObjectConvertToTypeCallbackEx1BCEA974
func jSObjectConvertToTypeCallbackEx1BCEA974(cctx C.JSContextRef, cjsClass C.JSClassRef, cobject C.JSObjectRef, ckind C.JSType, cexception *C.JSValueRef) C.JSValueRef {
	if jSObjectConvertToTypeCallbackEx1BCEA974Func != nil {
		ctx1bcea974 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		jsClass1bcea974 := *(*JSClassRef)(unsafe.Pointer(&cjsClass))
		object1bcea974 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		kind1bcea974 := (JSType)(ckind)
		var exception1bcea974 []JSValueRef
		hxf5d1de2 := (*sliceHeader)(unsafe.Pointer(&exception1bcea974))
		hxf5d1de2.Data = unsafe.Pointer(cexception)
		hxf5d1de2.Cap = 0x7fffffff
		// hxf5d1de2.Len = ?

		ret1bcea974 := jSObjectConvertToTypeCallbackEx1BCEA974Func(ctx1bcea974, jsClass1bcea974, object1bcea974, kind1bcea974, exception1bcea974)
		ret, _ := *(*C.JSValueRef)(unsafe.Pointer(&ret1bcea974)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectConvertToTypeCallbackEx1BCEA974Func JSObjectConvertToTypeCallbackEx

// allocJSStaticValueMemory allocates memory for type C.JSStaticValue in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSStaticValueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSStaticValueValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfJSStaticValueValue = unsafe.Sizeof([1]C.JSStaticValue{})

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	str = safeString(str)
	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *JSStaticValue) Ref() *C.JSStaticValue {
	if x == nil {
		return nil
	}
	return x.ref34655956
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *JSStaticValue) Free() {
	if x != nil && x.allocs34655956 != nil {
		x.allocs34655956.(*cgoAllocMap).Free()
		x.ref34655956 = nil
	}
}

// NewJSStaticValueRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewJSStaticValueRef(ref unsafe.Pointer) *JSStaticValue {
	if ref == nil {
		return nil
	}
	obj := new(JSStaticValue)
	obj.ref34655956 = (*C.JSStaticValue)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *JSStaticValue) PassRef() (*C.JSStaticValue, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref34655956 != nil {
		return x.ref34655956, nil
	}
	mem34655956 := allocJSStaticValueMemory(1)
	ref34655956 := (*C.JSStaticValue)(mem34655956)
	allocs34655956 := new(cgoAllocMap)
	allocs34655956.Add(mem34655956)

	var cname_allocs *cgoAllocMap
	ref34655956.name, cname_allocs = unpackPCharString(x.Name)
	allocs34655956.Borrow(cname_allocs)

	var cgetProperty_allocs *cgoAllocMap
	ref34655956.getProperty, cgetProperty_allocs = x.GetProperty.PassValue()
	allocs34655956.Borrow(cgetProperty_allocs)

	var csetProperty_allocs *cgoAllocMap
	ref34655956.setProperty, csetProperty_allocs = x.SetProperty.PassValue()
	allocs34655956.Borrow(csetProperty_allocs)

	var cattributes_allocs *cgoAllocMap
	ref34655956.attributes, cattributes_allocs = (C.JSPropertyAttributes)(x.Attributes), cgoAllocsUnknown
	allocs34655956.Borrow(cattributes_allocs)

	x.ref34655956 = ref34655956
	x.allocs34655956 = allocs34655956
	return ref34655956, allocs34655956

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x JSStaticValue) PassValue() (C.JSStaticValue, *cgoAllocMap) {
	if x.ref34655956 != nil {
		return *x.ref34655956, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *JSStaticValue) Deref() {
	if x.ref34655956 == nil {
		return
	}
	x.Name = packPCharString(x.ref34655956.name)
	x.GetProperty = *NewJSObjectGetPropertyCallbackRef(unsafe.Pointer(&x.ref34655956.getProperty))
	x.SetProperty = *NewJSObjectSetPropertyCallbackRef(unsafe.Pointer(&x.ref34655956.setProperty))
	x.Attributes = (JSPropertyAttributes)(x.ref34655956.attributes)
}

// allocJSStaticValueExMemory allocates memory for type C.JSStaticValueEx in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSStaticValueExMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSStaticValueExValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfJSStaticValueExValue = unsafe.Sizeof([1]C.JSStaticValueEx{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *JSStaticValueEx) Ref() *C.JSStaticValueEx {
	if x == nil {
		return nil
	}
	return x.ref6c5f7756
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *JSStaticValueEx) Free() {
	if x != nil && x.allocs6c5f7756 != nil {
		x.allocs6c5f7756.(*cgoAllocMap).Free()
		x.ref6c5f7756 = nil
	}
}

// NewJSStaticValueExRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewJSStaticValueExRef(ref unsafe.Pointer) *JSStaticValueEx {
	if ref == nil {
		return nil
	}
	obj := new(JSStaticValueEx)
	obj.ref6c5f7756 = (*C.JSStaticValueEx)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *JSStaticValueEx) PassRef() (*C.JSStaticValueEx, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6c5f7756 != nil {
		return x.ref6c5f7756, nil
	}
	mem6c5f7756 := allocJSStaticValueExMemory(1)
	ref6c5f7756 := (*C.JSStaticValueEx)(mem6c5f7756)
	allocs6c5f7756 := new(cgoAllocMap)
	allocs6c5f7756.Add(mem6c5f7756)

	var cname_allocs *cgoAllocMap
	ref6c5f7756.name, cname_allocs = unpackPCharString(x.Name)
	allocs6c5f7756.Borrow(cname_allocs)

	var cgetPropertyEx_allocs *cgoAllocMap
	ref6c5f7756.getPropertyEx, cgetPropertyEx_allocs = x.GetPropertyEx.PassValue()
	allocs6c5f7756.Borrow(cgetPropertyEx_allocs)

	var csetPropertyEx_allocs *cgoAllocMap
	ref6c5f7756.setPropertyEx, csetPropertyEx_allocs = x.SetPropertyEx.PassValue()
	allocs6c5f7756.Borrow(csetPropertyEx_allocs)

	var cattributes_allocs *cgoAllocMap
	ref6c5f7756.attributes, cattributes_allocs = (C.JSPropertyAttributes)(x.Attributes), cgoAllocsUnknown
	allocs6c5f7756.Borrow(cattributes_allocs)

	x.ref6c5f7756 = ref6c5f7756
	x.allocs6c5f7756 = allocs6c5f7756
	return ref6c5f7756, allocs6c5f7756

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x JSStaticValueEx) PassValue() (C.JSStaticValueEx, *cgoAllocMap) {
	if x.ref6c5f7756 != nil {
		return *x.ref6c5f7756, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *JSStaticValueEx) Deref() {
	if x.ref6c5f7756 == nil {
		return
	}
	x.Name = packPCharString(x.ref6c5f7756.name)
	x.GetPropertyEx = *NewJSObjectGetPropertyCallbackExRef(unsafe.Pointer(&x.ref6c5f7756.getPropertyEx))
	x.SetPropertyEx = *NewJSObjectSetPropertyCallbackExRef(unsafe.Pointer(&x.ref6c5f7756.setPropertyEx))
	x.Attributes = (JSPropertyAttributes)(x.ref6c5f7756.attributes)
}

// allocJSStaticFunctionMemory allocates memory for type C.JSStaticFunction in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSStaticFunctionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSStaticFunctionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfJSStaticFunctionValue = unsafe.Sizeof([1]C.JSStaticFunction{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *JSStaticFunction) Ref() *C.JSStaticFunction {
	if x == nil {
		return nil
	}
	return x.ref6b5f4953
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *JSStaticFunction) Free() {
	if x != nil && x.allocs6b5f4953 != nil {
		x.allocs6b5f4953.(*cgoAllocMap).Free()
		x.ref6b5f4953 = nil
	}
}

// NewJSStaticFunctionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewJSStaticFunctionRef(ref unsafe.Pointer) *JSStaticFunction {
	if ref == nil {
		return nil
	}
	obj := new(JSStaticFunction)
	obj.ref6b5f4953 = (*C.JSStaticFunction)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *JSStaticFunction) PassRef() (*C.JSStaticFunction, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6b5f4953 != nil {
		return x.ref6b5f4953, nil
	}
	mem6b5f4953 := allocJSStaticFunctionMemory(1)
	ref6b5f4953 := (*C.JSStaticFunction)(mem6b5f4953)
	allocs6b5f4953 := new(cgoAllocMap)
	allocs6b5f4953.Add(mem6b5f4953)

	var cname_allocs *cgoAllocMap
	ref6b5f4953.name, cname_allocs = unpackPCharString(x.Name)
	allocs6b5f4953.Borrow(cname_allocs)

	var ccallAsFunction_allocs *cgoAllocMap
	ref6b5f4953.callAsFunction, ccallAsFunction_allocs = x.CallAsFunction.PassValue()
	allocs6b5f4953.Borrow(ccallAsFunction_allocs)

	var cattributes_allocs *cgoAllocMap
	ref6b5f4953.attributes, cattributes_allocs = (C.JSPropertyAttributes)(x.Attributes), cgoAllocsUnknown
	allocs6b5f4953.Borrow(cattributes_allocs)

	x.ref6b5f4953 = ref6b5f4953
	x.allocs6b5f4953 = allocs6b5f4953
	return ref6b5f4953, allocs6b5f4953

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x JSStaticFunction) PassValue() (C.JSStaticFunction, *cgoAllocMap) {
	if x.ref6b5f4953 != nil {
		return *x.ref6b5f4953, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *JSStaticFunction) Deref() {
	if x.ref6b5f4953 == nil {
		return
	}
	x.Name = packPCharString(x.ref6b5f4953.name)
	x.CallAsFunction = *NewJSObjectCallAsFunctionCallbackRef(unsafe.Pointer(&x.ref6b5f4953.callAsFunction))
	x.Attributes = (JSPropertyAttributes)(x.ref6b5f4953.attributes)
}

// allocJSStaticFunctionExMemory allocates memory for type C.JSStaticFunctionEx in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSStaticFunctionExMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSStaticFunctionExValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfJSStaticFunctionExValue = unsafe.Sizeof([1]C.JSStaticFunctionEx{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *JSStaticFunctionEx) Ref() *C.JSStaticFunctionEx {
	if x == nil {
		return nil
	}
	return x.refc9fcc4d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *JSStaticFunctionEx) Free() {
	if x != nil && x.allocsc9fcc4d != nil {
		x.allocsc9fcc4d.(*cgoAllocMap).Free()
		x.refc9fcc4d = nil
	}
}

// NewJSStaticFunctionExRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewJSStaticFunctionExRef(ref unsafe.Pointer) *JSStaticFunctionEx {
	if ref == nil {
		return nil
	}
	obj := new(JSStaticFunctionEx)
	obj.refc9fcc4d = (*C.JSStaticFunctionEx)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *JSStaticFunctionEx) PassRef() (*C.JSStaticFunctionEx, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc9fcc4d != nil {
		return x.refc9fcc4d, nil
	}
	memc9fcc4d := allocJSStaticFunctionExMemory(1)
	refc9fcc4d := (*C.JSStaticFunctionEx)(memc9fcc4d)
	allocsc9fcc4d := new(cgoAllocMap)
	allocsc9fcc4d.Add(memc9fcc4d)

	var cname_allocs *cgoAllocMap
	refc9fcc4d.name, cname_allocs = unpackPCharString(x.Name)
	allocsc9fcc4d.Borrow(cname_allocs)

	var ccallAsFunctionEx_allocs *cgoAllocMap
	refc9fcc4d.callAsFunctionEx, ccallAsFunctionEx_allocs = x.CallAsFunctionEx.PassValue()
	allocsc9fcc4d.Borrow(ccallAsFunctionEx_allocs)

	var cattributes_allocs *cgoAllocMap
	refc9fcc4d.attributes, cattributes_allocs = (C.JSPropertyAttributes)(x.Attributes), cgoAllocsUnknown
	allocsc9fcc4d.Borrow(cattributes_allocs)

	x.refc9fcc4d = refc9fcc4d
	x.allocsc9fcc4d = allocsc9fcc4d
	return refc9fcc4d, allocsc9fcc4d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x JSStaticFunctionEx) PassValue() (C.JSStaticFunctionEx, *cgoAllocMap) {
	if x.refc9fcc4d != nil {
		return *x.refc9fcc4d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *JSStaticFunctionEx) Deref() {
	if x.refc9fcc4d == nil {
		return
	}
	x.Name = packPCharString(x.refc9fcc4d.name)
	x.CallAsFunctionEx = *NewJSObjectCallAsFunctionCallbackExRef(unsafe.Pointer(&x.refc9fcc4d.callAsFunctionEx))
	x.Attributes = (JSPropertyAttributes)(x.refc9fcc4d.attributes)
}

// allocJSClassDefinitionMemory allocates memory for type C.JSClassDefinition in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSClassDefinitionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSClassDefinitionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfJSClassDefinitionValue = unsafe.Sizeof([1]C.JSClassDefinition{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *JSClassDefinition) Ref() *C.JSClassDefinition {
	if x == nil {
		return nil
	}
	return x.ref192c18d5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *JSClassDefinition) Free() {
	if x != nil && x.allocs192c18d5 != nil {
		x.allocs192c18d5.(*cgoAllocMap).Free()
		x.ref192c18d5 = nil
	}
}

// NewJSClassDefinitionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewJSClassDefinitionRef(ref unsafe.Pointer) *JSClassDefinition {
	if ref == nil {
		return nil
	}
	obj := new(JSClassDefinition)
	obj.ref192c18d5 = (*C.JSClassDefinition)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *JSClassDefinition) PassRef() (*C.JSClassDefinition, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref192c18d5 != nil {
		return x.ref192c18d5, nil
	}
	mem192c18d5 := allocJSClassDefinitionMemory(1)
	ref192c18d5 := (*C.JSClassDefinition)(mem192c18d5)
	allocs192c18d5 := new(cgoAllocMap)
	allocs192c18d5.Add(mem192c18d5)

	var cversion_allocs *cgoAllocMap
	ref192c18d5.version, cversion_allocs = (C.int)(x.Version), cgoAllocsUnknown
	allocs192c18d5.Borrow(cversion_allocs)

	var cattributes_allocs *cgoAllocMap
	ref192c18d5.attributes, cattributes_allocs = (C.JSClassAttributes)(x.Attributes), cgoAllocsUnknown
	allocs192c18d5.Borrow(cattributes_allocs)

	var cclassName_allocs *cgoAllocMap
	ref192c18d5.className, cclassName_allocs = unpackPCharString(x.ClassName)
	allocs192c18d5.Borrow(cclassName_allocs)

	var cparentClass_allocs *cgoAllocMap
	ref192c18d5.parentClass, cparentClass_allocs = *(*C.JSClassRef)(unsafe.Pointer(&x.ParentClass)), cgoAllocsUnknown
	allocs192c18d5.Borrow(cparentClass_allocs)

	var cprivateData_allocs *cgoAllocMap
	ref192c18d5.privateData, cprivateData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PrivateData)), cgoAllocsUnknown
	allocs192c18d5.Borrow(cprivateData_allocs)

	x.ref192c18d5 = ref192c18d5
	x.allocs192c18d5 = allocs192c18d5
	return ref192c18d5, allocs192c18d5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x JSClassDefinition) PassValue() (C.JSClassDefinition, *cgoAllocMap) {
	if x.ref192c18d5 != nil {
		return *x.ref192c18d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *JSClassDefinition) Deref() {
	if x.ref192c18d5 == nil {
		return
	}
	x.Version = (int32)(x.ref192c18d5.version)
	x.Attributes = (JSClassAttributes)(x.ref192c18d5.attributes)
	x.ClassName = packPCharString(x.ref192c18d5.className)
	x.ParentClass = *(*JSClassRef)(unsafe.Pointer(&x.ref192c18d5.parentClass))
	x.PrivateData = (unsafe.Pointer)(unsafe.Pointer(x.ref192c18d5.privateData))
}

// copyPULStringBytes copies the data from Go slice as *C.ULString.
func copyPULStringBytes(slice *sliceHeader) (*C.ULString, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfULStringValue) * slice.Len,
		Cap:  int(sizeOfULStringValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.ULString)(mem0), allocs
}

// allocULStringMemory allocates memory for type C.ULString in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULStringMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULStringValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULStringValue = unsafe.Sizeof([1]C.ULString{})

// copyPULChar16Bytes copies the data from Go slice as *C.ULChar16.
func copyPULChar16Bytes(slice *sliceHeader) (*C.ULChar16, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfULChar16Value) * slice.Len,
		Cap:  int(sizeOfULChar16Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.ULChar16)(mem0), allocs
}

// allocULChar16Memory allocates memory for type C.ULChar16 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocULChar16Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfULChar16Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfULChar16Value = unsafe.Sizeof([1]C.ULChar16{})

// copyPJSValueRefBytes copies the data from Go slice as *C.JSValueRef.
func copyPJSValueRefBytes(slice *sliceHeader) (*C.JSValueRef, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfJSValueRefValue) * slice.Len,
		Cap:  int(sizeOfJSValueRefValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.JSValueRef)(mem0), allocs
}

// allocJSValueRefMemory allocates memory for type C.JSValueRef in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSValueRefMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSValueRefValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfJSValueRefValue = unsafe.Sizeof([1]C.JSValueRef{})

// unpackArgSJSClassDefinition transforms a sliced Go data structure into plain C format.
func unpackArgSJSClassDefinition(x []JSClassDefinition) (unpacked *C.JSClassDefinition, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocJSClassDefinitionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.JSClassDefinition)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.JSClassDefinition)(h.Data)
	return
}

// packSJSClassDefinition reads sliced Go data structure out from plain C format.
func packSJSClassDefinition(v []JSClassDefinition, ptr0 *C.JSClassDefinition) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfJSClassDefinitionValue]C.JSClassDefinition)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewJSClassDefinitionRef(unsafe.Pointer(&ptr1))
	}
}

// copyPJSObjectRefBytes copies the data from Go slice as *C.JSObjectRef.
func copyPJSObjectRefBytes(slice *sliceHeader) (*C.JSObjectRef, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfJSObjectRefValue) * slice.Len,
		Cap:  int(sizeOfJSObjectRefValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.JSObjectRef)(mem0), allocs
}

// allocJSObjectRefMemory allocates memory for type C.JSObjectRef in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSObjectRefMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSObjectRefValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfJSObjectRefValue = unsafe.Sizeof([1]C.JSObjectRef{})

// copyPJSStringRefBytes copies the data from Go slice as *C.JSStringRef.
func copyPJSStringRefBytes(slice *sliceHeader) (*C.JSStringRef, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfJSStringRefValue) * slice.Len,
		Cap:  int(sizeOfJSStringRefValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.JSStringRef)(mem0), allocs
}

// allocJSStringRefMemory allocates memory for type C.JSStringRef in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSStringRefMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSStringRefValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfJSStringRefValue = unsafe.Sizeof([1]C.JSStringRef{})

// copyPJSCharBytes copies the data from Go slice as *C.JSChar.
func copyPJSCharBytes(slice *sliceHeader) (*C.JSChar, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfJSCharValue) * slice.Len,
		Cap:  int(sizeOfJSCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.JSChar)(mem0), allocs
}

// allocJSCharMemory allocates memory for type C.JSChar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfJSCharValue = unsafe.Sizeof([1]C.JSChar{})

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})
